<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Dynamic Timer Components with Voice Recorder</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Rethink+Sans:wght@400..800&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="scroll.css">

  <style>
    .inline-block {
      display: inline-block;
    }

    body {
      font-family: "Rethink Sans", -apple-system, BlinkMacSystemFont, avenir next, avenir, segoe ui, helvetica neue,
        helvetica, Cantarell, Ubuntu, roboto, noto, arial, sans-serif;
      font-optical-sizing: auto;
      font-weight: 400;
      font-style: normal;
      line-height: 1.67;
      background-color: #e5e7e9;
    }

    input {
      font-size: inherit;
      background-color: transparent;
    }

    .config {
      margin-bottom: 20px;
    }

    #defaultTime {
      font-size: 24px;
      border: none;
      background-color: #f9f9f8;
    }

    #timerList {
      /* display timers in an auto-flowing grid */
      display: contents;
      grid-template-columns: repeat(auto-fit, minmax(496px, max-content));
      grid-auto-rows: auto;
      grid-gap: 12px;
      margin: 20px 0px;


      /* display: flex; */
      /*flex-wrap: wrap; /* /* Allows wrapping if the screen size is too small */
      /* gap: 10px;/* /* Optional, for spacing between the timers */

    }

    /* .timer {
      display: flex;
      flex-direction: row;
      align-items: center;
      background-color: #f9f9f8;
      border-radius: 8px 20px 20px 8px;
      width: max-content;
      margin: 10px 0px;
    } */

    .timer-title {
      /* elegant and readable editable title */
      width: 144px;
      font-family: "Rethink Sans", -apple-system, BlinkMacSystemFont, avenir next, avenir, segoe ui, helvetica neue,
        helvetica, Cantarell, Ubuntu, roboto, noto, arial, sans-serif;
      font-optical-sizing: auto;
      font-weight: 500;
      line-height: 1.67;
      font-size: 18px;
      border: none;
      flex-basis: 1;
      margin-left: 16px;
      margin-right: 16px;
      text-align: center;
      background-color: #f0f0f0;
    }

    .timer-value {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      width: 80px;
      border: none;
      color: gold;
      font-weight: 600;
      background: black;
      margin-right: 8px;
      border-radius: 10px;
      text-align: center;
    }

    .timer-asc {
      width: 80px;
      text-align: center;
      border: none;
      /*added by subhadra*/
      border-radius: 10px;
      font-size: 16px;
      padding: 5px;
    }

    .timer-value:focus {
      border: initial;
      color: black;
      background-color: yellow;
    }

    .timer-asc:focus {
      border: initial;
      background-color: yellow;
    }

    /*added by subhadra*/
    .flex-row {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }


    .btn-container {
      padding: 4px;
      border-radius: 20px;
      position: relative;
      margin: 0;
      overflow: auto;
      background: -moz-linear-gradient(top, #aca79b 0%, #fcfbfa 100%);
      background: -webkit-linear-gradient(top, #aca79b 0%, #fcfbfa 100%);
      background: linear-gradient(to bottom, #aca79b 0%, #fcfbfa 100%);
    }

    .btn-container:before {
      content: "";
      display: block;
      clear: both;
      width: calc(100% - 11px);
      box-shadow: inset 0 0 50px #000;
      position: absolute;
      top: 50%;
      left: 50%;
      height: calc(100% - 9px);
      transform: translateX(-50%) translateY(-50%);
      border-radius: 17px;
    }

    .btn-container>button {
      font-size: 14px;
      position: relative;
      padding: 9px 12px;
      border: none;
      z-index: 1;
      border-radius: 15px;
      margin: 3px 2px 3px 0px;
      box-shadow: inset 0 2px 2px #fff, inset 0 -1px 2px #aeaba4;
      background: #ece7df;
      line-height: 1;
      transition: all 0.15s ease;
    }

    .btn-container>button:first-child {
      margin-left: 4px;
      margin-right: 2px;
    }

    .btn-container>button:last-child {
      margin-left: 0px;
      margin-right: 4px;
    }

    .btn-container>button:only-child {
      margin-left: 4px;
      margin-right: 4px;
    }



    .btn-container>button:hover {
      box-shadow: inset 0 1px 1px #fff, inset 0 -1px 2px #aeaba4, inset 0 0 1px rgba(0, 0, 0, 0.25),
        inset 0 0px 1px rgba(0, 0, 0, 0.25);

    }

    .btn-container>button:active {
      box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.25), inset 0 5px 10px rgba(0, 0, 0, 0.25), inset 0 2px 2px #ddd,
        inset 0 -1px 2px #9d9b94;
    }

    .btn-container>button:active:after {
      width: 67%;
      height: 67%;
    }

    .btn-container .start-pause-btn {
      padding-left: 48px;
      padding-right: 48px;
    }



    /* Add your styles here */
    .timer {

      flex-direction: row;
      border-radius: 8px 20px 20px 8px;
      width: max-content;
      margin: 10px 0px;
      display: flex;
      align-items: center;
      gap: 10px;
      background-color: #f9f9f8;
      padding: 10px;
      border-radius: 8px;
    }

    .timer-title {
      font-size: 18px;
      font-weight: bold;
      width: 150px;
      text-align: center;
      border: none;
      background-color: #f0f0f0;
    }

    .timer-value {
      width: 80px;
      font-size: 24px;
      text-align: center;
      border: none;
    }

    button {
      padding: 5px 10px;
      font-size: 16px;
    }



    /* content */



    /* .show-dropdown {
      display: flex;
    } */
    /*changes 1*/
    .show-dropdown {
      display: flex;
      opacity: 1;
      /* left: 55%; */
      gap: 5px;
      margin-top: 10px;
      transform: scale(1);
    }



    .dropdown-item {
      padding: 5px 10px;
      cursor: pointer;
    }

    .dropdown-item:hover {
      background-color: #f0f0f0;
    }






    /* content */

    /* Dropdown Menu Base Styles */
    .dropdown-menu {
      display: none;
      position: absolute;
      background-color: white;
      border: 1px solid #ccc;
      padding: 10px;
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      transition: opacity 0.3s ease, transform 0.3s ease;
      opacity: 0;
      transform: scale(0.9);


    }

    /*added by subhadra - starts*/
    .show-dropdown {
      display: flex;
      opacity: 1;

      gap: 5px;
      margin-top: 15px;
      transform: scale(1);
    }

    /* Main Menu Item Styles */
    .dropdown-item {
      position: relative;
      padding: 10px 14px;
      cursor: pointer;
      background: #f4f4f4;
      border-radius: 5px;
      transition: background-color 0.3s ease;
    }

    .dropdown-item:hover {
      background: #4caf50;
      color: #fff;
    }

    /* Submenu Styles */
    .submenu {
      display: none;
      position: absolute;
      /* left: 100%; */
      top: 38px;
      background: #f9f9f9;
      border-radius: 5px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      padding: 10px;
      opacity: 0;
      transform: translateX(10px);
      transition: opacity 0.3s ease, transform 0.3s ease;
    }

    .submenu.show {
      display: flex;
      opacity: 1;
      top: 100%;
      transform: translateX(0);
      z-index: 1;
    }

    /*.dropdown-item:hover .submenu {
      display: flex;
      opacity: 1;
      transform: translateX(0);
    }*/

    /* Submenu Item Styles */
    .submenu-item {
      display: block;
      padding: 8px 16px;
      background: #e0e0e0;
      border-radius: 4px;
      margin: 5px 0;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }

    .submenu-item:hover {
      background: #81c784;
      color: #fff;
    }

    .row {
      display: flex;
      justify-content: space-between;
      gap: 20px;
      margin-top: 20px;
    }

    .col {
      flex: 1;
      padding: 20px;
      background-color: #ffffff;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      border-radius: 8px;
    }

    #contentForm input {
      border-radius: 5px;
      padding: 5px 10px;
    }




    /* style section for top star data  */


    .info-container {
      display: flex;
      flex-wrap: wrap;
      /* Allows wrapping for smaller screens */
      gap: 15px;
      padding: 15px;
      border-radius: 10px;
      font-family: Arial, sans-serif;
      /* justify-content: center; */
    }

    .info-box {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 12px 18px;
      background: white;
      border-radius: 8px;
      box-shadow: 0px 2px 6px rgba(0, 0, 0, 0.1);
      white-space: nowrap;
      /* Prevents breaking text inside */
    }

    .info-box span {
      font-weight: bold;
      color: #333;
    }

    .info-box p {
      margin: 0;
      color: #555;
    }

    /* Responsive Design */
    @media (max-width: 768px) {
      .info-container {
        flex-direction: column;
        /* Stack elements in a column */
        align-items: center;
      }

      .info-box {
        width: 90%;
        /* Makes boxes take more space on smaller screens */
        justify-content: center;
      }


      /*added by Subhadra */

      .timer {
        flex-direction: column;
        align-items: flex-start;
      }

      .timer-title {
        font-size: 18px;
        width: 100px;
      }

      .timer-value {
        font-size: 18px;
        width: 60px;
      }


      .timer-input {
        overflow-x: visible;
      }

      .timer-asc {
        font-size: 14px;
        width: 50px;
      }

      .flex-row {
        display: flex;
        flex-wrap: wrap;

        flex-direction: row;
        justify-content: flex-start;
        overflow-x: visible;
      }



      .vote-btn,
      .donateUserTIme {
        flex-basis: 0%;
      }

      .btn-container>button {
        font-size: 12px;
        padding: 8px 10px;

      }

      .row {
        flex-direction: column;
      }

      .col {
        width: 100%;
        margin-bottom: 15px;
      }

      .show-dropdown {
        display: flex;
        left: 25%;
        margin-top: 15px;
      }

      .dropdown-item {
        font-size: 14px;
      }

      .submenu {
        margin-top: 5px;
        display: flex;

      }
    }

    button#resetVotesBtn {
      padding: 5px 10px;
      border: none;
      background-color: black;
      color: white;
      border-radius: 5px;
      cursor: pointer;
      font-size: 14px;
    }

    #voteData {
      font-weight: bold;
      color: #333;
    }

    /* end star section */



    /* people section */
    .dropdown-item.active {
      background-color: green !important;
      color: white;
    }






    #click-counts-list {
      list-style: none;
      padding: 0;
      margin: 0;
      max-width: 700px;
      background: #f8f9fa;
      border-radius: 8px;
      padding: 15px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    }

    #click-counts-list li {
      background: white;
      border-radius: 6px;
      padding: 12px;
      margin: 10px 0;
      display: flex;
      align-items: center;
      justify-content: space-between;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      font-family: Arial, sans-serif;
    }

    #click-counts-list li span {
      flex: 1;
      font-size: 14px;
      color: #333;
    }

    #click-counts-list li input {
      width: 50px;
      padding: 4px;
      border: 1px solid #ddd;
      border-radius: 4px;
      text-align: center;
    }

    #click-counts-list li button {
      background: #007bff;
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.3s ease-in-out;
    }

    #click-counts-list li button:hover {
      background: #0056b3;
    }

    h3 {
      font-size: 18px;
      color: #222;
      margin-bottom: 10px;
    }

    /* people section end */

    /*donate css button*/
    #donateUserTIme {
      background-color: #ff69b4;
      /* Hot pink */
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 5px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.2s ease;
      box-shadow: 0 4px 10px rgba(255, 105, 180, 0.3);
    }

    #donateUserTIme:hover {
      background-color: #ff1493;
      /* Deep pink on hover */
      transform: translateY(-2px);
      box-shadow: 0 6px 14px rgba(255, 20, 147, 0.4);
    }

    #donateUserTIme:active {
      background-color: #e0137d;
      transform: translateY(0);
      box-shadow: 0 3px 8px rgba(224, 19, 125, 0.3);
    }


    .user-card {
      position: absolute;
      background-color: #fff;
      border: 1px solid #ddd;
      border-radius: 5px;
      padding: 5px 16px;

      left: 48%;
      transform: translateX(-38.5%);

      margin: 0px 3px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
      max-width: 400px;
      font-family: 'Segoe UI', sans-serif;
    }


    .time-display {
      /* display: flex; */
      /* justify-content: space-between; */
      align-items: center;
    }

    .time-label {
      font-weight: 600;
      color: #555;
    }

    .time-value {
      font-size: 18px;
      color: #333;
      font-weight: bold;
    }

    .donation-controls {
      display: flex;
      flex-direction: flex;
      gap: 10px;
    }

    .time-inputs {
      display: flex;
      gap: 8px;
    }

    .time-inputs input {
      width: 90px;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid #ccc;
      font-size: 14px;
    }

    .donation-target {
      padding: 8px;
      font-size: 14px;
      border-radius: 8px;
      border: 1px solid #ccc;
    }

    .donate-btn {
      background-color: #ff69b4;
      /* Pink */
      color: white;
      border: none;
      /* padding: 10px; */
      border-radius: 12px;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 10px rgba(255, 105, 180, 0.2);
    }

    .donate-btn:hover {
      background-color: #ff1493;
      box-shadow: 0 6px 14px rgba(255, 20, 147, 0.3);
      transform: translateY(-2px);
    }

    /* .donate-btn:active {
      background-color: #e0137d;
      box-shadow: 0 3px 8px rgba(224, 19, 125, 0.2);
      transform: translateY(0);
    } */

    /* changes 2 */
    .donate-btn:active {
      background-color: #e0137d;
      box-shadow: 0 3px 8px rgba(224, 19, 125, 0.2);
      transform: translateY(0);
      width: 50%;
    }



    /*scroll effect in form submenu */

    /* .scroll-container {
      display: flex;
      justify-content: center;
      gap: 0px;
      position: relative;
    }

    .scroll-box {
      width: 60px;
      height: 40px;
      overflow-y: scroll;
      text-align: center;
      font-weight: bold;
      user-select: none;
      scroll-snap-type: y mandatory;
      border: 1px solid #ccc;
    }

    .scroll-box div {
      padding: 10px;
      scroll-snap-align: center;
      cursor: pointer;
      transition: all 0.2s;
    }

    .scroll-box.scrolling {
      height: 300px;
    }

    .scroll-box::-webkit-scrollbar {
      display: none;
    } */


    .scroll-wrapper {
      position: relative;
      display: inline-block;
    }

    /* Timer scroll container floats like a dropdown */
    .scroll-container {
      position: absolute;
      top: 40px;
      left: 0;
      background: #fff;
      border: 1px solid #ccc;
      padding: 10px;
      border-radius: 10px;
      display: flex;
      gap: 10px;
      z-index: 1000;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }

    /* Make scroll boxes easier to drag and scroll */
    .scroll-box {
      width: 60px;
      height: 200px;
      overflow-y: scroll;
      scroll-snap-type: y mandatory;
      border: 1px solid #ddd;
      background-color: #f9f9f9;
      text-align: center;
      font-size: 14px;
      user-select: none;
      -webkit-overflow-scrolling: touch;
    }

    .scroll-box div {
      padding: 16px 0;
      scroll-snap-align: center;
      cursor: pointer;
    }

    .scroll-box::-webkit-scrollbar {
      width: 0;
    }

    .time-option {
      font-size: 14px;
    }



    .selected {
      font-size: 18px;
      font-weight: bold;
      background: #007bff;
      color: white;
    }

    .formbtntimersubmenu {
      padding: 10px 20px;
      font-size: 16px;
      background-color: #007bff;
      border: none;
      color: white;
      cursor: pointer;
      transition: 0.3s;
    }

    .formbtntimersubmenu:hover {
      background-color: #0056b3;
    }

    #form-submenu-timer-status {
      font-size: 16px;
      margin-top: 10px;
    }




    /*scroll effect in form submenu end*/




    /*togle cycle start*/

    .toggle-btn {
      background-color: #007bff;
      color: white;
      border: none;
      padding: 10px 15px;
      cursor: pointer;
      font-size: 16px;
      border-radius: 5px;
    }

    .toggle-btn:hover {
      background-color: #0056b3;
    }

    .table-container {
      margin-top: 10px;
      overflow: hidden;
      transition: max-height 0.4s ease-out;
    }

    .hidden {
      max-height: 0;
      visibility: hidden;
      transition: max-height 0.4s ease-in, visibility 0.2s ease-in;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 10px;
    }

    th,
    td {
      border: 1px solid #ddd;
      padding: 10px;
      text-align: left;
    }

    th {
      background-color: #f4f4f4;
    }

    .timer-veto {
      width: 150px;
      padding: 8px 12px;
      font-size: 14px;
      border: 2px solid #ccc;
      border-radius: 4px;
      background-color: #f9f9f9;
      color: #333;
      transition: border-color 0.3s, background-color 0.3s;
    }

    /* Change border color when the input field is focused */
    .timer-veto:focus {
      border-color: #4CAF50;
      background-color: #e8f5e9;
      outline: none;
    }

    /* Add a box shadow effect for better focus */
    .timer-veto:focus {
      box-shadow: 0 0 8px rgba(76, 175, 80, 0.5);
    }

    /* Optional: Add placeholder text styling */
    .timer-veto::placeholder {
      color: #999;
      /* Gray placeholder text */
      font-style: italic;
    }

    /*togle cycle end*/

    /* veto selection start */

    .vetoSelectionData {
      display: flex;
      flex-wrap: wrap;
      /* Allows wrapping if there's not enough space */
      gap: 10px;
      justify-content: flex-start;
      /* Aligns items to the left */
    }

    .vetoSelection {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .vetoSelectionSubmenu {
      display: none;
      /* Hide the radio buttons */
    }

    .vetoSelectionLabel {
      padding: 10px 20px;
      background-color: #b5b800;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
      transition: background-color 0.3s ease, transform 0.3s ease;
      display: inline-block;
    }

    .vetoSelectionLabel:hover {
      background-color: purple;
      transform: scale(1.05);
      /* Slightly enlarges the button on hover */
    }

    .vetoSelectionSubmenu:checked+.vetoSelectionLabel {
      background-color: purple;
      /* Change background when selected */
      transform: scale(1.05);
      /* Enlarge the selected label */
    }

    label {
      cursor: pointer;
    }

    #updateVeto {
      margin-top: 20px;
      padding: 10px;
      background-color: #4CAF50;
      color: white;
      border: none;
      cursor: pointer;
    }

    #updateVeto:hover {
      background-color: purple;
    }


    /* veto selection end */
  </style>
</head>

<body>
  <div class="config">
    <label>
      <input type="checkbox" id="notifyCheckbox" />
      Enable System Notifications
    </label>

    <!-- <h1>Showing up on time helps give Sacred time. Otherwise others can donate some of their sacred time.</h1>
    <br /> -->


    <label class="defaultTimeLabel">
      Default Time:
      <input type="text" id="defaultTime" value="5:00" placeholder="Default Time M:SS" />
    </label>
    <div class="btn-container inline-block">
      <button id="addTimerBtn" title="Add A Timer">‚ûï</button>
    </div>

    <div class="info-container">
      <div class="info-box">
        ‚≠ê <span>Votes:</span>
        <p id="voteData">
          Total Votes: 0
        </p>
      </div>


      <div class="info-box">
        ‚≠ê <span>Form:</span>
        <p>Straight turn</p>
      </div>

      <div class="info-box">
        ‚≠ê <span>Content:</span>
        <p>Universal-Ai</p>
      </div>

      <div class="info-box">
        ‚≠ê <span>People:</span>
        <p>Same</p>
      </div>
    </div>






    <div id="numberCitizenTimers">Number Citizen Timers: 0</div>

    <button id="resetVotesBtn" title="Reset Votes">Reset Votes</button>
    <!-- <button id="updateVeto" title="Update Veto">Update Veto</button> -->



    <div class="vetoSelectionData" style="display: none;">
      <div class="vetoSelection">
        <input type="radio" class="vetoSelectionSubmenu" name="vetoSelection" id="straightturn" value="straightturn">
        <label class="vetoSelectionLabel" for="straightturn">Straight Turn</label>
      </div>

      <div class="vetoSelection">
        <input type="radio" class="vetoSelectionSubmenu" name="vetoSelection" id="directiveTurn" value="directiveTurn">
        <label class="vetoSelectionLabel" for="directiveTurn">Directive Turn</label>
      </div>

      <div class="vetoSelection">
        <input type="radio" class="vetoSelectionSubmenu" name="vetoSelection" id="popcornTurn" value="popcornTurn">
        <label class="vetoSelectionLabel" for="popcornTurn">Popcorn Turn</label>
      </div>

      <div class="vetoSelection">
        <input type="radio" class="vetoSelectionSubmenu" name="vetoSelection" id="fastFreeFlow" value="fastFreeFlow">
        <label class="vetoSelectionLabel" for="fastFreeFlow">Fast Free Flow</label>
      </div>

      <div class="vetoSelection">
        <input type="radio" class="vetoSelectionSubmenu" name="vetoSelection" id="teamFreeFlow" value="teamFreeFlow">
        <label class="vetoSelectionLabel" for="teamFreeFlow">Team Free Flow</label>
      </div>

      <div class="vetoSelection">
        <input type="radio" class="vetoSelectionSubmenu" name="vetoSelection" id="spreadFreeFlow"
          value="spreadFreeFlow">
        <label class="vetoSelectionLabel" for="spreadFreeFlow">Spread Free Flow</label>
      </div>

      <div class="vetoSelection">
        <input type="radio" class="vetoSelectionSubmenu" name="vetoSelection" id="god" value="god">
        <label class="vetoSelectionLabel" for="god">God</label>
      </div>

      <div class="vetoSelection">
        <input type="radio" class="vetoSelectionSubmenu" name="vetoSelection" id="diety" value="diety">
        <label class="vetoSelectionLabel" for="diety">Diety</label>
      </div>

      <div class="vetoSelection">
        <input type="radio" class="vetoSelectionSubmenu" name="vetoSelection" id="spirit" value="spirit">
        <label class="vetoSelectionLabel" for="spirit">Spirit</label>
      </div>
    </div>




    <!-- <div id="voteData">Total Votes: 0</div> -->
    <h3>Vote Counts:</h3>
    <ul id="click-counts-list"></ul> <!-- This will hold the list of button click counts -->
    <div id="people-click-counts-container" style="margin-top: 10px;">
      <h3>People Selection Count</h3>
      <ul id="people-click-counts-list"></ul>
    </div>







    <style>
      .history-content {
        display: flex;
        justify-content: space-between;
        gap: 20px;
      }

      #donationConsoleOutput,
      #unapprovedItems {
        width: 50%;
        box-sizing: border-box;
      }

      #donationConsoleOutput {
        list-style-type: none;
        padding: 0;
        margin: 0;
      }

      #donationConsoleOutput li {
        padding: 5px 0;
        border-bottom: 1px solid #ddd;
        color: #555;
      }

      .button-with-label {
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      .tiny-label {
        font-size: 4px;
        margin-top: 2px;
        color: gray;
      }
    </style>

    <div id="donationHistoryContainer" class="donation-box">
      <h3>üïí Donation History</h3>
      <div class="history-content">
        <ul id="donationConsoleOutput"></ul>
        <div id="unapprovedItems"></div>
      </div>
      <div id="approvedDonationsOutput"></div>

      <button onclick="showdonationhistory()">Show Donation History</button>

    </div>














    <button class="toggle-btn" onclick="toggleTable()">Total Cycle</button>

    <button onclick="showSelectedTimers()">Show Selected Timers</button>


    <div class="table-container hidden" id="tableContainer">
      <table>
        <thead>
          <tr>
            <th>User Name</th>
            <th>Cycle 1</th>
            <th>Cycle 2</th>
            <th>Cycle 3</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>John Doe</td>
            <td>cycle data</td>
            <td>cycle data</td>
            <td>cycle data</td>

          </tr>
          <tr>
            <td>Jane Smith</td>
            <td>cycle data</td>
            <td>cycle data</td>
            <td>cycle data</td>
          </tr>
          <tr>
            <td>Michael Brown</td>
            <td>cycle data</td>
            <td>cycle data</td>
            <td>cycle data</td>
          </tr>
        </tbody>
      </table>
    </div>

    <script>
      function toggleTable() {
        let tableContainer = document.getElementById("tableContainer");

        if (tableContainer.classList.contains("hidden")) {
          tableContainer.classList.remove("hidden");
          tableContainer.style.maxHeight = tableContainer.scrollHeight + "px";
        } else {
          tableContainer.style.maxHeight = "0";
          setTimeout(() => {
            tableContainer.classList.add("hidden");
          }, 400); // Delay to match transition
        }
      }
    </script>
  </div>


  <div id="contentDisplayContainer">
    <h2>Content Display</h2>
  </div>

  <div id="counterDisplay">
    Individual: <span id="individualCount">0</span> |
    Particular: <span id="particularCount">0</span> |
    Universal: <span id="universalCount">0</span>
  </div>


  <div id="timerList">
  </div>



  <script>

    let mainTimerInterval;
    let mainTimerSeconds = 600; // Timer starts at 10 minutes (600 seconds)
    let isTimerRunning = false;
    let numberCitizenTimers = 0;
    let globalTimerIDs = 0 //in createTimerComponent it generates a new ID for each one and each button has a subreference

    // Function to update the timer display
    function updateMainTimerDisplay() {
      let minutes = Math.floor(mainTimerSeconds / 60);
      let seconds = mainTimerSeconds % 60;
      document.getElementById("mainTimer").value = `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }


    function displayDonationMessageOnHTML(message, isTemporary = false, isRepeated = false) {
      const output = document.getElementById("donationConsoleOutput");
      if (output) {
        const li = document.createElement("li");
        li.textContent = message;

        if (isRepeated) {
          li.style.backgroundColor = "#ffcccc"; // Light red background
          li.style.padding = "5px";
          li.style.borderRadius = "4px";
        }

        output.appendChild(li);

        if (isTemporary) {
          setTimeout(() => {
            output.removeChild(li);
          }, 3000);
        }
      }
    }





    function showSelectedTimers() {
      const checkboxes = document.querySelectorAll('.timer-checkbox');
      checkboxes.forEach(checkbox => {
        if (checkbox.checked) {
          const timerDiv = checkbox.closest('.timer'); // The parent timer component div
          const timerTitleInput = timerDiv.querySelector('.timer-title'); // Find the title input
          console.log("Selected Timer Title:", timerTitleInput.value);
        }
      });
    }





    function startAscendingTimer(timerServerID, ascendingTime) {//ascendingTime is in seconds
      let timerComponent = document.getElementById(timerServerID)
      let timerAsc = document.querySelector(`[data-id="${timerServerID}-3"]`)
      // let [ascMinutes, ascSecondsRaw] = timerAsc.value.split(":").map(num => parseInt(num, 10));
      //ascSeconds = ascMinutes * 60 + ascSecondsRaw;

      allAscendingTimersByServerID[timerServerID] = setInterval(() => {
        console.log("Automatic AscendingTimer Stop:" + timerServerID);
        let startPauseBtn = document.querySelector(`[data-id="${timerServerID}-5"]`)

        if (startPauseBtn.dataset.status == "currently_paused") {
          console.log("Automatic2 AscendingTimer Stop:" + timerServerID);
          clearInterval(allAscendingTimersByServerID[timerServerID]);
          delete allAscendingTimersByServerID[timerServerID]

          return;

        }//end if

        ascendingTime++;
        const mins = Math.floor(ascendingTime / 60).toString();
        const secs = (ascendingTime % 60).toString().padStart(2, "0");
        timerAsc.value = `${mins}:${secs}`;
      }, 1000);
    }//end startAscendingTimer


    function startTimer(timerServerID, serverTime) {
      // Clear background color when timer starts
      console.log("startTimer(timerServerID):" + timerServerID);

      let timerComponent = document.getElementById(timerServerID);
      console.log("startTimer(timerComponent:" + timerComponent + " " + JSON.stringify(timerComponent));
      let timerValue = document.querySelector(`[data-id="${timerServerID}-2"]`)
      console.log("startTimer(timerValue" + timerValue + " " + JSON.stringify(timerValue));
      //let startPauseBtn = document.querySelector(`[data-id="${timerServerID}-5"]`)
      //console.log("startPauseBtn:"+ JSON.stringify(startPauseBtn));
      let totalSeconds = serverTime;
      timerComponent.style.backgroundColor = "#c5eba9"; // Turn bg color to light green

      //      let [minutes, seconds] = serverTime.value.split(":").map(num => parseInt(num, 10));
      //        let totalSeconds = minutes * 60 + seconds;

      allTimersByServerID[timerServerID] = setInterval(() => {

        if (totalSeconds <= 0) {
          clearInterval(allTimersByServerID[timerServerID]);
          delete allTimersByServerID[timerServerID]
          let timerComponent2 = document.getElementById(timerServerID);
          timerComponent2.style.backgroundColor = "orange";
          //onComplete();
          let startPauseBtn = document.querySelector(`[data-id="${timerServerID}-5"]`)
          startPauseBtn.textContent = "‚ñ∂Ô∏è";
          startPauseBtn.dataset.status = "currently_paused";
          //stop the ascending timer when the count down reaches
          let responseObject = {
            cmd: "stopTimer",
            msg: {
              ELMxID: 0, //hardcoded so switch when meetings dynamic
              timerServerID: timerServerID,
            }//end msg
          };//end responseObject

          // Send the request to the server to update the timer state for all clients
          socket.send(JSON.stringify(responseObject));


          return;
        }
        totalSeconds--;

        const mins = Math.floor(totalSeconds / 60).toString();
        const secs = (totalSeconds % 60).toString().padStart(2, "0");
        timerValue.value = `${mins}:${secs}`;
      }, 1000);
      let startPauseBtn = document.querySelector(`[data-id="${timerServerID}-5"]`)
      // currentRunningTimer = timerComponent; // Set the current running timer
      startPauseBtn.textContent = "‚è∏Ô∏è ";
      startPauseBtn.dataset.status = "currently_running";
    }//end startTimer(timerServerID)


    function stopTimer(timerServerIDStop) {
      //this is triggered when manually select timer and inputting new time in block time

      let timerElementStop = document.getElementById(timerServerIDStop);


      console.log("StopTimer:" + timerServerIDStop + " " + JSON.stringify(timerElementStop));
      if (timerElementStop) {


        console.log("Returning from server to stop timer on brower");
        let localTimerIDStop = allTimersByServerID[timerServerIDStop]
        let localAscendingTimerIDStop = allAscendingTimersByServerID[timerServerIDStop]
        console.log("localTimerIDStop:" + localTimerIDStop + " " + JSON.stringify(allTimersByServerID));
        clearInterval(localTimerIDStop);
        clearInterval(localAscendingTimerIDStop);
        delete allTimersByServerID[timerServerIDStop];
        delete allAscendingTimersByServerID[timerServerIDStop];
        let startPauseBtnStop = document.querySelector(`[data-id="${timerServerIDStop}-5"]`)
        startPauseBtnStop.textContent = "‚ñ∂Ô∏è";  // Change button text to 'Play' or 'Start'
        let timeElement = document.querySelector(`[data-id="${timerServerIDStop}-2"]`)
        console.log("StopTimer TotalSeconds:" + JSON.stringify(timeElement));
        let timeLeft = timeElement.value;
        console.log("StopTimer2 TotalSeconds:" + timeElement.value);
        let [minutes, seconds] = timeLeft.split(":").map(num => parseInt(num, 10));
        let totalSeconds = minutes * 60 + seconds;
        console.log("StopTimer3 TotalSeconds:" + totalSeconds);
        if (totalSeconds <= 0) {
          timerElementStop.style.backgroundColor = "orange";
        } else {
          timerElementStop.style.backgroundColor = "";  // Reset background color
        }//end if
        startPauseBtnStop.dataset.status = "currently_paused";

      }//end timerElementStop

    }//end stopTimer



    // Function to update the timer title (if needed)
    function updateTimerTitle() {
      const newTitle = document.getElementById("timerTitle").value;
      console.log("Timer title updated to: " + newTitle);

      //const inputField = document.getElementById('timerTitle'); // The ID of the input field

      // title.addEventListener('blur', function() {
      const timerNameElement = document.querySelector(`.timer[id2="${timerID}"]`);
      console.log("timerNameElement in mainTimer:" + JSON.stringify(timerNameElement))
      //const timerNewName = inputField.value; // Get the value entered by the user
      const ELMxID = 0; // You can change this to the actual ELMxID if dynamic
      //hereMark
      const timerNewName = timerNameElement.value; // Get the value entered by the user
      const timerNewTitleID = timerNameElement.id2; // Get the value entered by the user
      //const ELMxID = 0; // You can change this to the actual ELMxID if dynamic
      console.log("Event Listener set in createTimerComponent: " + timerNewName);

      // Send the new timer name to the server when the user unfocuses the input field
      socket.send(JSON.stringify("inside of blur updateTimerTitleName"));
      let responseObject = { "cmd": "resetTimerName", "msg": { "ELMxID": ELMxID, "timerNewTitleID": timerNewTitleID, "timerNewName": timerNewName } }
      socket.send(JSON.stringify(responseObject));
      console.log("Timer title sending to socket: " + timerNewName);
      //});//end event handler blur
    }//end updateTimerTitle

    // Toggle between start and pause button
    function toggleStartPause() {
      if (isTimerRunning) {
        clearInterval(mainTimerInterval);
        mainTimerInterval = null;
        isTimerRunning = false;
        document.getElementById("toggleStartPauseBtn").textContent = "‚ñ∂Ô∏è"; // Start icon
      } else {
        startMainTimer();
        document.getElementById("toggleStartPauseBtn").textContent = "‚è∏Ô∏è"; // Pause icon
      }
    }

    // Function to start the main timer
    function startMainTimer() {
      if (!mainTimerInterval && mainTimerSeconds > 0) {
        mainTimerInterval = setInterval(() => {
          if (mainTimerSeconds > 0) {
            mainTimerSeconds--;
            updateMainTimerDisplay();
          } else {
            clearInterval(mainTimerInterval);
            mainTimerInterval = null;
            isTimerRunning = false;
            document.getElementById("toggleStartPauseBtn").textContent = "‚ñ∂Ô∏è"; // Reset to start button
          }
        }, 1000);
        isTimerRunning = true;
      }
    }


    // Function to update the timer value from user input
    function updateMainTimerFromInput() {
      const input = document.getElementById("mainTimer").value;
      const parts = input.split(":");
      if (parts.length === 2) {
        let mins = parseInt(parts[0], 10);
        let secs = parseInt(parts[1], 10);
        if (!isNaN(mins) && !isNaN(secs) && secs >= 0 && secs < 60) {
          mainTimerSeconds = mins * 60 + secs;
          updateMainTimerDisplay();
        }
      }
    }






    // Function to reset the timer
    function resetMainTimer() {
      clearInterval(mainTimerInterval);
      mainTimerInterval = null;
      isTimerRunning = false;
      mainTimerSeconds = 600;
      updateMainTimerDisplay();
      document.getElementById("toggleStartPauseBtn").textContent = "‚ñ∂Ô∏è"; // Start icon
    }

    // Event listener to pause the timer when editing the input
    document.getElementById("mainTimer").addEventListener("focus", () => {
      if (isTimerRunning) {
        clearInterval(mainTimerInterval);
        mainTimerInterval = null;
        isTimerRunning = false;
        document.getElementById("toggleStartPauseBtn").textContent = "‚ñ∂Ô∏è"; // Change button to start icon
      }
    });

    // Event listener to update the timer when input loses focus
    document.getElementById("mainTimer").addEventListener("blur", updateMainTimerFromInput);

    // Initialize display
    updateMainTimerDisplay();




    // function showdonationhistory() {
    //   let timerServerID = "yourTimerID"; // Define this somewhere if needed

    //   let responseObject = {
    //     cmd: "getDonationMessages",
    //     msg: {
    //       ELMxID: 0, // Hardcoded, update dynamically as needed
    //       timerServerID: timerServerID,
    //     }
    //   };

    //   // Send the request to the server
    //   socket.send(JSON.stringify(responseObject));
    // }


    function showdonationhistory() {
      let timerServerID = "yourTimerID"; // Define this somewhere if needed

      // Request donation history (messages + unapprovalmessage)
      let donationHistoryRequest = {
        cmd: "getDonationMessages",
        msg: {
          ELMxID: 0, // Update dynamically if needed
          timerServerID: timerServerID,
        }
      };

      // Request approved donations separately
      // let approvedDonationsRequest = {
      //   cmd: "getApprovedDonations",
      //   msg: {
      //     ELMxID: 0, // Same ELMxID
      //   }
      // };

      // Send both requests to the server
      socket.send(JSON.stringify(donationHistoryRequest));
      // socket.send(JSON.stringify(approvedDonationsRequest));

      console.log("üì§ Sent getDonationMessages and getApprovedDonations requests");
    }







    // Global donation tracking
    let donationCounts = {};

    // Grab usernames directly from DOM when needed
    function getUsernameByID(userID) {
      const input = document.querySelector(`[data-id="${userID}-1"]`);
      return input ? input.value.trim() || `User ${userID}` : `User ${userID}`;
    }

    function getUserOptions(currentUserID, excludeIDs = []) {
      let options = "";

      document.querySelectorAll(`[data-id$="-1"]`).forEach(input => {
        const userID = input.getAttribute("data-id").split("-")[0];
        if (userID !== currentUserID && !excludeIDs.includes(userID)) {
          const userName = input.value.trim() || `User ${userID}`;
          options += `<option value="${userID}">${userName}</option>`;
        }
      });

      return options;
    }


    // function renderApprovedDonations(approvedDonations) {
    //   const approvedDonationsContainer = document.getElementById('approvedDonationsOutput'); // Make sure you have this div in your HTML

    //   approvedDonationsContainer.innerHTML = ""; // Clear previous output

    //   if (approvedDonations.length === 0) {
    //     approvedDonationsContainer.innerHTML = "<p>No approved donations found.</p>";
    //     return;
    //   }

    //   approvedDonations.forEach((donation, index) => {
    //     const donationItem = document.createElement('div');
    //     donationItem.classList.add('approved-donation-item');
    //     donationItem.innerHTML = `
    //         <p><strong>Donation #${index + 1}</strong></p>
    //         <p>${JSON.stringify(donation)}</p>
    //         <hr>
    //     `;
    //     approvedDonationsContainer.appendChild(donationItem);
    //   });
    // }

    // Renders approved donations
    function renderApprovedDonations(approvedDonations) {
      const approvedDonationsContainer = document.getElementById('approvedDonationsOutput');

      approvedDonationsContainer.innerHTML = "";

      // Turn object into array of values
      const donationsArray = Object.values(approvedDonations);

      if (donationsArray.length === 0) {
        approvedDonationsContainer.innerHTML = "<p>No approved donations found.</p>";
        return;
      }

      donationsArray.forEach((donation, index) => {
        const donationItem = document.createElement('div');
        donationItem.classList.add('approved-donation-item');
        donationItem.innerHTML = `
      <p><strong>Donation #${index + 1}</strong></p>
      <p>From: ${donation.fromUserID} ‚Üí To: ${donation.toUserID}</p>
      <p>Timer: ${donation.timerName || "(No Name)"}</p>
      <p>Minutes: ${donation.minutes}, Seconds: ${donation.seconds}</p>
      <hr>
    `;
        approvedDonationsContainer.appendChild(donationItem);
      });
    }

    
    // Show pending approval
    function showPendingApproval(data) {
      console.log("show pending approval check data ", data);

      const approverOptions = getUserOptions(null, [data.fromUserID.toString(), data.toUserID.toString()]);

      const fromName = getUsernameByID(data.fromUserID);
      const toName = getUsernameByID(data.toUserID);

      const container = document.createElement("div");

      // Make the ID truly unique
      const uniqueApprovalID = `approval-${data.ELMxID}-${data.fromUserID}-${data.toUserID}-${data.totalSeconds}`;
      container.id = uniqueApprovalID;

      container.innerHTML = `
    <div class="pending-approval">
      <p><strong>${fromName} ‚ûú ${toName}</strong> (${data.minutes} min ${data.seconds} sec)</p>
      <select class="approver-dropdown">${approverOptions}</select>
      <button class="approve-btn">Approve</button>
      <button class="remove-btn">Remove</button>
    </div>
  `;

      // Approve button click
      container.querySelector(".approve-btn").addEventListener("click", () => {
        const approverID = container.querySelector(".approver-dropdown").value;
        if (!approverID || approverID == data.fromUserID || approverID == data.toUserID) {
          alert("Invalid approver.");
          return;
        }

        sendDonation(data, parseInt(approverID));

        container.remove(); // Remove this box locally

        // Notify other browsers to remove it too
        socket.send(JSON.stringify({
          cmd: "sendingremoveApprovalUI",
          msg: {
            ELMxID: data.ELMxID,
            fromUserID: data.fromUserID,
            toUserID: data.toUserID,
            totalSeconds: data.totalSeconds
          }
        }));
      });

      // Remove button click
      container.querySelector(".remove-btn").addEventListener("click", () => {
        if (confirm("Are you sure you want to remove this pending approval?")) {
          container.remove(); // Remove this box locally

          // First: Tell server to **remove from memory** (VERY IMPORTANT)
          socket.send(JSON.stringify({
            cmd: "removeApprovedDonation",
            msg: {
              ELMxID: data.ELMxID,
              fromUserID: data.fromUserID,
              toUserID: data.toUserID,
              totalSeconds: data.totalSeconds
            }
          }));

          console.log("‚ùå Manual removal of approval sent to server:", {
            ELMxID: data.ELMxID,
            fromUserID: data.fromUserID,
            toUserID: data.toUserID,
            totalSeconds: data.totalSeconds
          });

          // Second: Also notify other browsers to remove from their UI
          socket.send(JSON.stringify({
            cmd: "sendingremoveApprovalUI",
            msg: {
              ELMxID: data.ELMxID,
              fromUserID: data.fromUserID,
              toUserID: data.toUserID,
              totalSeconds: data.totalSeconds
            }
          }));
        }
      });

      document.getElementById("unapprovedItems").appendChild(container);
    }


    // Get username by ID
    function getUsernameByID(userID) {
      const input = document.querySelector(`[data-id="${userID}-1"]`);
      return input ? input.value.trim() || `User ${userID}` : `User ${userID}`;
    }

    // Send donation
    // function sendDonation(data, approverID = null) {
    //   const payload = {
    //     cmd: "donateTime",
    //     msg: {
    //       ELMxID: 0,
    //       fromUserID: data.fromUserID,
    //       toUserID: data.toUserID,
    //       timerName: data.timerName,
    //       minutes: data.minutes,
    //       seconds: data.seconds,
    //       totalSeconds: data.totalSeconds
    //     }
    //   };

    //   if (approverID) {
    //     payload.msg.approvedByID = approverID;
    //     payload.msg.approvedByName = getUsernameByID(approverID);
    //   }

    //   socket.send(JSON.stringify(payload));
    //   console.log("Donation sent via WebSocket:", payload);
    // }

    // function sendDonation(data, approverID = null) {
    //   const payload = {
    //     cmd: "donateTime",
    //     msg: {
    //       ELMxID: 0,
    //       fromUserID: data.fromUserID,
    //       toUserID: data.toUserID,
    //       timerName: data.timerName,
    //       minutes: data.minutes,
    //       seconds: data.seconds,
    //       totalSeconds: data.totalSeconds
    //     }
    //   };

    //   // Add approver info if it's provided
    //   if (approverID) {
    //     payload.msg.approvedByID = approverID;
    //     payload.msg.approvedByName = getUsernameByID(approverID);
    //   }

    //   // Send the donation information to the server
    //   socket.send(JSON.stringify(payload));
    //   console.log("Donation sent via WebSocket:", payload);

    //   // After donation is sent, notify the server to remove the approved donation from the server
    //   socket.send(JSON.stringify({
    //     cmd: "removeApprovedDonation",
    //     msg: {
    //       fromUserID: data.fromUserID,
    //       toUserID: data.toUserID,
    //       totalSeconds: data.totalSeconds
    //     }
    //   }));

    //   console.log("Approved donation removal requested:", {
    //     fromUserID: data.fromUserID,
    //     toUserID: data.toUserID,
    //     totalSeconds: data.totalSeconds
    //   });
    // }


    function sendDonation(data, approverID = null) {
      const payload = {
        cmd: "donateTime",
        msg: {
          ELMxID: 0, // Always include the ELMxID
          fromUserID: data.fromUserID,
          toUserID: data.toUserID,
          timerName: data.timerName,
          minutes: data.minutes,
          seconds: data.seconds,
          totalSeconds: data.totalSeconds
        }
      };

      // Add approver info if provided
      if (approverID) {
        payload.msg.approvedByID = approverID;
        payload.msg.approvedByName = getUsernameByID(approverID);
      }

      // Send the donation information to the server
      socket.send(JSON.stringify(payload));
      console.log("Donation sent via WebSocket:", payload);

      // After donation is sent, notify the server to remove the approved donation
      const removalPayload = {
        cmd: "removeApprovedDonation",
        msg: {
          ELMxID: 0, // <-- Make sure to include ELMxID here also
          fromUserID: data.fromUserID,
          toUserID: data.toUserID,
          totalSeconds: data.totalSeconds
        }
      };

      socket.send(JSON.stringify(removalPayload));
      console.log("Approved donation removal requested:", removalPayload);
    }


    // Render donation messages
    function renderDonationMessages(messages) {
      console.log("üì¶ Messages received in renderDonationMessages:", messages);

      const output = document.getElementById("donationConsoleOutput");
      if (!output) {
        console.error("‚ùå Element with ID 'donationConsoleOutput' not found.");
        return;
      }

      output.innerHTML = "";

      if (!messages || messages.length === 0) {
        const li = document.createElement("li");
        li.textContent = "No donation history found.";
        output.appendChild(li);
        return;
      }

      messages.forEach((entry, index) => {
        console.log(`üîπ Entry ${index + 1}:`, entry);

        const {
          timerName,
          donatedMinutes,
          donatedSeconds,
          recipientName,
          toUserID,
          donationCount,
          approvedByName
        } = entry;

        let messageText = `${timerName || "Timer"} Donated ${donatedMinutes}m ${donatedSeconds}s to ${recipientName || toUserID}`;
        if (donationCount) {
          messageText += ` (Donated ${donationCount} ${donationCount === 1 ? "time" : "times"})`;
        }
        if (approvedByName) {
          messageText += ` ‚úÖ Approved by ${approvedByName}`;
        }

        const li = document.createElement("li");
        li.textContent = `${index + 1}. ${messageText}`;

        if (donationCount && donationCount > 1) {
          li.style.backgroundColor = "#ffcccc";
          li.style.padding = "5px";
          li.style.borderRadius = "4px";
        }

        output.appendChild(li);
      });
    }



    function handleShowApproval(msg) {
      console.log("üîµ handleShowApproval received:", msg);

      const approvalList = document.getElementById('unapprovedItems');
      if (!approvalList) {
        console.error("‚ö†Ô∏è 'approvalList' element not found!");
        return;
      }

      approvalList.innerHTML = ''; // Clear previous list

      // Loop over each approval
      for (const key in msg) {
        const approvalData = msg[key];

        const {
          fromUserID,
          toUserID,
          timerName,
          minutes,
          seconds,
          totalSeconds
        } = approvalData;

        const approverOptions = getUserOptions(null, [fromUserID.toString(), toUserID.toString()]);

        const item = document.createElement('div');
        item.className = 'approval-item';
        item.innerHTML = `
      <p><strong>User ${fromUserID}</strong> wants to donate 
      <strong>${minutes}m ${seconds}s</strong> to 
      <select class="approver-dropdown">${approverOptions}</select>
      <strong>User ${toUserID}</strong> (Timer: <em>${timerName}</em>)</p>

      <button class="approve-btn">Approve</button>
      <button class="remove-btn">Remove</button>
    `;

        approvalList.appendChild(item);

        const approveButton = item.querySelector('.approve-btn');
        const removeButton = item.querySelector('.remove-btn');

        approveButton.addEventListener('click', () => {
          const approverID = item.querySelector('.approver-dropdown').value;
          if (!approverID || approverID == fromUserID || approverID == toUserID) {
            alert("Invalid approver.");
            return;
          }

          sendDonation({ fromUserID, toUserID, timerName, minutes, seconds, totalSeconds }, parseInt(approverID));
          item.remove(); // Remove the item after approval
        });

        removeButton.addEventListener('click', () => {
          // Create a message to remove the approval without approving
          const removalPayload = {
            cmd: "removeApprovedDonation",
            msg: {
              ELMxID: 0, // If you have dynamic ELMxID, replace 0 accordingly
              fromUserID: fromUserID,
              toUserID: toUserID,
              totalSeconds: totalSeconds
            }
          };

          socket.send(JSON.stringify(removalPayload));
          console.log("‚ùå Manual removal requested:", removalPayload);

          item.remove(); // Remove the item immediately from UI
        });
      }
    }



    function removeApprovalBox(data) {
    const approvalID = `approval-${data.ELMxID}-${data.fromUserID}-${data.toUserID}-${data.totalSeconds}`;
    const approvalElement = document.getElementById(approvalID);

    if (approvalElement) {
        approvalElement.remove();
        console.log("‚úÖ Approval box removed:", approvalID);
    } else {
        console.log("‚ö†Ô∏è Approval box not found:", approvalID);
    }
}



  </script>



  <script>
    // const socket = new WebSocket("ws://69.197.142.130:8084");
    const socket = new WebSocket("http://localhost:8084/");
    const donationTracker = {};

    socket.onopen = function () {
      console.log("Connected to   WebSocket server");
    };


    socket.onmessage = function (event) {//RETURN FROM SERVER SWITCH STARTS HERE
      const data = JSON.parse(event.data);

      console.log("Received update:", data);



      //Main Switch/Switch Main
      switch (data.cmd) {//messages from server



        // case "returnNewUserIDWithScreenCatchUp":

        //   let allELMxData = data.msg.allMeetingData; //for this meeting currently hardcoded at ELM "0"
        //   let allTimersData = allELMxData.timers

        //   console.log("In browser returnNewUserIDWithScreenCatchUp:" + JSON.stringify(allTimersData));

        //   for (let key in allTimersData) {
        //     if (allTimersData.hasOwnProperty(key)) {
        //       //NOTE: Feb 19 2025: before you can run these DOM functions, the DOMContentLoaded must load but the websocket starts before it so we must load the variables until DOM is done and grab them.
        //       // Your code to access the key and its value
        //       let singleTimerData = allTimersData[key];
        //       // Create the timer component in this browser
        //       numberCitizenTimers++; // Update total number for VoteReset and color
        //       // Broadcast the new timer to all connected clients
        //       const browserIndTimerDefault = singleTimerData.remainingTime;
        //       const serverTimerID = singleTimerData.timerServerID;
        //       console.log("MAIN SWITCH:createTimerComponentToBrowser" + " " + "browserIndTimerDefault:" + browserIndTimerDefault)


        //       const timerContainer = document.getElementById("timerList");
        //       //const newTimerComponent = document.createElement("div");
        //       //newTimerComponent.innerHTML = data.timerComponent;
        //       //timerContainer.appendChild(newTimerComponent);
        //       // const timerComponent = createTimerComponent(singleTimerData, timerContainer); //this has no socket.send in it

        //       // const  vetoTimerData= allELMxData.timers.vetoes.formVeto;
        //       // const  vetoTimerData= allELMxData.timers.veto;
        //       // console.log("veto Timer Data " + JSON.stringify(vetoTimerData));

        //       const timerComponent = createTimerComponent(singleTimerData, timerContainer); //this has no socket.send in it

        //       setupTimerControls(timerComponent, browserIndTimerDefault);

        //       document.getElementById("numberCitizenTimers").textContent = `Number Citizen Timers: ${numberCitizenTimers}`;


        //       console.log("key:" + key + " singleTimer:" + JSON.stringify(singleTimerData));
        //     }//end if statement
        //   }//end for loop
        //   break;


        case "returnNewUserIDWithScreenCatchUp":
          let allELMxData = data.msg.allMeetingData; // for this meeting, currently hardcoded at ELM "0"
          let allTimersData = allELMxData.timers;

          console.log("In browser returnNewUserIDWithScreenCatchUp:" + JSON.stringify(allTimersData));

          for (let key in allTimersData) {
            if (allTimersData.hasOwnProperty(key)) {
              // Wait for DOMContentLoaded before running DOM-dependent code
              let singleTimerData = allTimersData[key];
              numberCitizenTimers++; // Update total number for VoteReset and color

              const browserIndTimerDefault = singleTimerData.remainingTime;
              const serverTimerID = singleTimerData.timerServerID;

              console.log("MAIN SWITCH:createTimerComponentToBrowser browserIndTimerDefault:", browserIndTimerDefault);

              const timerContainer = document.getElementById("timerList");
              const timerComponent = createTimerComponent(singleTimerData, timerContainer); // has no socket.send in it
              setupTimerControls(timerComponent, browserIndTimerDefault);

              document.getElementById("numberCitizenTimers").textContent = `Number Citizen Timers: ${numberCitizenTimers}`;

              console.log("key:", key, "singleTimerData:", JSON.stringify(singleTimerData));

              // ‚úÖ Restore Veto Input Field and Update Click Count Map
              const vetoValue = singleTimerData.veto; // e.g., "f-2"
              const inputField = document.querySelector(`[data-id="${key}-4"]`);

              if (inputField) {
                inputField.value = vetoValue;

                if (vetoValue && vetoValue.startsWith("f-")) {
                  const count = parseInt(vetoValue.split("-")[1], 10);
                  vetoClickCountMap[key] = count;
                } else {
                  vetoClickCountMap[key] = 0;
                }

                console.log(`Restored vetoClickCountMap[${key}] = ${vetoClickCountMap[key]}`);
              }
            }
          }
          break;


        // case "donationMessagesList":
        //   const messages = data.msg.messages;
        //   const unapprovalmessage = data.msg.unapprovalmessage;
        //   // const { messages, unapprovalmessage } = data.msg;
        //   // renderDonationMessages(messages, unapprovalmessage); // Pass both messages to the function
        //   console.log("unapproval message ", unapprovalmessage);
        //   renderDonationMessages(messages);
        //   handleShowApproval(unapprovalmessage);

        //   break;

        // case "donationMessagesList":
        //   const messages = data.msg.messages;           // ‚úÖ approved donation history
        //   const unapprovalmessage = data.msg.unapprovalmessage; // ‚úÖ pending approval

        //   console.log("unapproval message ", unapprovalmessage);

        //   renderDonationMessages(messages);      // ‚¨ÖÔ∏è  Renders into donationConsoleOutput
        //   handleShowApproval(unapprovalmessage); // ‚¨ÖÔ∏è  Renders pending approval

        //   break;


        case "donationMessagesList":
          const messages = data.msg.messages;
          const unapproveusermessage = data.msg.unapproveusermessage;  // Correct field name
          console.log("üü† unapproveusermessage:", unapproveusermessage);
          renderDonationMessages(messages);
          handleShowApproval(unapproveusermessage);  // Pass correct data
          break;



        case "approvedDonationsList":
          const approvedDonations = data.msg.approvedDonations; // ‚úÖ Approved donations

          console.log("‚úÖ Approved Donations: ", approvedDonations);

          // renderApprovedDonations(approvedDonations); // ‚¨ÖÔ∏è A new function you will create

          break;





        case "returnedFromServerAddTimer": //this one is from server for the non Optimistic UI draw but the one from the server
          // Create the timer component in this browser
          numberCitizenTimers++; // Update total number for VoteReset and color
          // Broadcast the new timer to all connected clients
          let allThisTimerData = data.msg.allMeetingData
          const browserIndTimerDefault = data.msg.allMeetingData.defaultTime;
          const serverTimerID = data.msg.allMeetingData.newTimerID;
          const timerTitle = data.msg.allMeetingData.name;
          console.log("MAIN SWITCH:createTimerComponentToBrowser" + " " + "browserIndTimerDefault:" + browserIndTimerDefault)
          console.log("MAIN SWITCH:createTimerComponentToBrowser: NAME:" + timerTitle)

          const timerContainer = document.getElementById("timerList");
          //const newTimerComponent = document.createElement("div");
          //newTimerComponent.innerHTML = data.timerComponent;
          //timerContainer.appendChild(newTimerComponent);
          const timerComponent = createTimerComponent(allThisTimerData, timerContainer); //this has no socket.send in it
          setupTimerControls(timerComponent, browserIndTimerDefault);
          document.getElementById("numberCitizenTimers").textContent = `Number Citizen Timers: ${numberCitizenTimers}`;
          break;

        case "returnedFromServerResetTimerName":
          //input  msg: { ELMxID: 0, timerNewTitleID: '', timerNewName: 'Mark' } }
          let timerNewName = data.msg.timerNewName;
          let resetTimerName_timerServerID = data.msg.timerServerID;
          let nameElementID = resetTimerName_timerServerID + "-1";//Feb 19 2025: where did we get the -1 from? Its just a code we made to differentiaete the elements with custom data-id. It is made by the timer over ID with the component number with a "-" seperating them.
          console.log("nameElementID:" + nameElementID);
          const titleInputField = document.querySelector(`[data-id="${nameElementID}"]`);//timerComponent.querySelector('.timer-title'); // Use class selector

          console.log("newTimerName:" + timerNewName + " element" + JSON.stringify(titleInputField));

          titleInputField.value = timerNewName;

          break;

        case "returnedFromServerManualSetTime":
          //input  msg: { ELMxID: 0, timerNewTitleID: '', timerNewName: 'Mark' } }
          let timerNewManualTime = data.msg.timerNewName;
          let manualTimeElementID = data.msg.manualTimeElementID;;
          console.log("nameElementID:" + nameElementID);
          const manualTimeInputField = document.querySelector(`[data-id="${nameElementID}"]`);//timerComponent.querySelector('.timer-title'); // Use class selector

          console.log("newTimerName:" + timerNewName + " element" + JSON.stringify(manualTimeInputField));


          manualTimeInputField.value = timerNewName;

          break;

        case "timerRemoved":
          console.warn("Timer Removed event received:", JSON.stringify(data));

          const timerRemovalServerID = data.msg.timerRemovalServerID;
          const ELMxID_Remove = data.msg.ELMxID_Remove;

          let defaultRemoveButtonElementID = `${timerRemovalServerID}-8`;
          console.log("Searching for Remove Button with ID:", defaultRemoveButtonElementID);

          // Try finding the element with expected ID
          let timerRemoveElement = document.querySelector(`[data-id="${defaultRemoveButtonElementID}"]`);

          if (!timerRemoveElement) {
            console.warn(`Timer with ID '${defaultRemoveButtonElementID}' not found. Trying alternative lookup...`);
            timerRemoveElement = document.querySelector(`[data-id="${timerRemovalServerID}"]`);
          }

          console.log("Final timerRemoveElement found:", timerRemoveElement);

          if (timerRemoveElement) {
            const timerContainer = document.getElementById(timerRemovalServerID);
            if (timerContainer) {
              timerContainer.remove();
              if (allTimersByServerID.hasOwnProperty(timerRemovalServerID)) {
                console.log("RemoveTimer delete allTimersByServerID[timerServerIDStop];" + timerRemovalServerID);
                let localTimerIDStop = allTimersByServerID[timerRemovalServerID]
                let localAscendingTimerIDStop = allAscendingTimersByServerID[timerRemovalServerID]
                console.log("localTimerIDStop:" + localTimerIDStop + " " + JSON.stringify(localAscendingTimerIDStop));
                clearInterval(localTimerIDStop);
                clearInterval(localAscendingTimerIDStop);
                delete allTimersByServerID[timerRemovalServerID];
                delete allAscendingTimersByServerID[timerRemovalServerID];
              }



              console.log(`‚úÖ Timer ${timerRemovalServerID} removed from the UI.`);
            } else {
              console.warn(`‚ö†Ô∏è Timer ${timerRemovalServerID} found but its parent container is missing.`);
            }
          } else {
            console.warn(`‚ùå Timer ${timerRemovalServerID} not found in the DOM.`);
          }

          break;






        case "returnRemoveApproval":
          console.log("üì© Received returnRemoveApproval message:", data);
          removeApprovalBox(data.msg);

          if (data.msg && typeof data.msg.ELMxID_unApproval !== "undefined") {
            const removeID = data.msg.ELMxID_unApproval;
            const element = document.getElementById(`approval-${removeID}`);

            if (element) {
              element.remove();
              console.log(`‚úÖ Removed approval UI for ELMxID: ${removeID}`);
            } else {
              console.warn(`‚ö†Ô∏è No element found with ID approval-${removeID}`);
            }
          } else {
            console.warn("‚ùå Missing or invalid ELMxID_unApproval in returnRemoveApproval:", data);
          }

          break;




        case "returnShowApproval":

          const original = data.msg;
          const remapped = {
            fromUserID: original.fromUserID_Approval,
            toUserID: original.toUserID_Approval,
            minutes: original.minutes_Approval,
            seconds: original.seconds_Approval,
            totalSeconds: original.totalSeconds_Approval,
            timerName: original.timerName_Approval,
            ELMxID: original.ELMxID_Approval
          };
          console.log("Showing approval UI:", remapped);


          showPendingApproval(remapped);
          // handleShowApproval(original);

          break;






        case "broadcastRemoveTimer":
          console.log("Received broadcastRemoveTimer:", data);
          document.querySelectorAll(`[data-id="${data.msg.timerRemovalServerID}"]`).forEach(el => {
            el.closest('.timer-container')?.remove();
            console.log(`Timer ${data.msg.timerRemovalServerID} removed in all tabs.`);
          });
          break;








        case "returnedFromServerResetDefaultTime":

          console.log("Received resetDefaultTime message: " + data.msg);  // Log the incoming message for debugging
          //  input  msg: { ELMxID: 0, timerNewTitleID: '', timerDefaultTime: 'Mark' } }
          let timerDefaultTime = data.msg.newDefaultTime;
          let resetDefaultTime_timerServerID = data.msg.timerServerID;
          let defaultTimeElementID = resetDefaultTime_timerServerID + "-2";//Feb 19 2025: where did we get the -1 from? Its just a code we made to differentiaete the elements with custom data-id. It is made by the timer over ID with the component number with a "-" seperating them.
          console.log("defaultTimeElementID:" + defaultTimeElementID);
          const defaultTimerInputField = document.querySelector(`[data-id="${defaultTimeElementID}"]`);//timerComponent.querySelector('.timer-title'); // Use class selector

          console.log("Default Timer value:" + timerDefaultTime + " element" + JSON.stringify(defaultTimerInputField));

          let minutes = Math.floor(timerDefaultTime / 60);  // Get the number of minutes
          let remainingSeconds = timerDefaultTime % 60;    // Get the remaining seconds

          // Pad seconds with a leading zero if needed
          remainingSeconds = remainingSeconds < 10 ? "0" + remainingSeconds : remainingSeconds;

          // Return formatted time in mm:ss format
          let timeString = `${minutes}:${remainingSeconds}`;

          defaultTimerInputField.value = timeString;
          break;




        case "returnedFromServerResetTimerAsc":
          // Input: msg: { ELMxID: 0, timerServerID: '123', timerAscValue: '00:01' }

          let timerAscValue = data.msg.timerAscValue;  // Get the updated ascending timer value from the server response
          let resetTimerAsc_timerServerID = data.msg.timerServerID; // Get the timerServerID
          let ascElementID = resetTimerAsc_timerServerID + "-3"; // Assuming -3 is used for ascending timer input fields

          console.log("ascElementID: " + ascElementID);  // Log the element ID for debugging

          // Find the input field element using the data-id (same pattern as the previous case)
          const ascInputField = document.querySelector(`[data-id="${ascElementID}"]`);

          console.log("newTimerAscValue: " + timerAscValue + " element: " + JSON.stringify(ascInputField));

          // Update the value of the input field with the new ascending timer value
          if (ascInputField) {
            ascInputField.value = timerAscValue;  // Set the new ascending timer value
          } else {
            console.log("Error: Could not find the input field for timer asc value with data-id: " + ascElementID);
          }

          break;

        case "returnedFromServerResetVetoName":
          // input msg: { ELMxID: 0, vetoNewTitleID: '', vetoNewName: 'Veto Mark' }
          let vetoNewName = data.msg.vetoNewName;
          let vetoElementID = data.msg.vetoElementID;
          console.log("vetoElementID:" + vetoElementID);

          const vetoInputField = document.querySelector(`[data-id="${vetoElementID}"]`); // Select the veto input field

          console.log("newVetoName:" + vetoNewName + " element" + JSON.stringify(vetoInputField));

          if (vetoInputField) {
            vetoInputField.value = vetoNewName;
          }
          break;





        case "returnedFromServerManualSetVetoTime":
          // input msg: { ELMxID: 0, vetoManualTimeID: '', vetoNewManualTime: '00:30' }
          let vetoNewManualTime = data.msg.vetoNewManualTime;
          let vetoManualTimeElementID = data.msg.vetoManualTimeElementID;
          console.log("vetoManualTimeElementID:" + vetoManualTimeElementID);

          const vetoManualTimeInputField = document.querySelector(`[data-id="${vetoManualTimeElementID}"]`); // Select the veto time input field

          console.log("newVetoManualTime:" + vetoNewManualTime + " element" + JSON.stringify(vetoManualTimeInputField));

          if (vetoManualTimeInputField) {
            vetoManualTimeInputField.value = vetoNewManualTime;
          }

          break;

        case "returnedStartTimer":
          let { timerServerID, shouldStart, ELMxID, serverTime, ascendingTime } = data.msg;
          // let timerElement = document.querySelector(`[data-id='${timerServerID}']`);
          let timerElement = document.getElementById(timerServerID);


          console.log("returnedStartTimer:" + timerServerID + " " + JSON.stringify(timerElement));
          if (timerElement) {

            // If the timer is starting

            console.log("Returning from server to start timer on brower");
            startTimer(timerServerID, serverTime);//NOTE: March 13 2025: the reason why we manually load the server's time for this timer is because each start and stop keeps the timers insynch with the server. 
            startAscendingTimer(timerServerID, ascendingTime);
            timerElement.style.backgroundColor = "green";  // Optional: change color to show it's running
            let startPauseBtn = document.querySelector(`[data-id="${timerServerID}-5"]`)
            startPauseBtn.textContent = "‚è∏Ô∏è";  // Change button text to 'Pause' or 'Stop'
            startPauseBtn.dataset.status = "currently_running";


          } //end if(timerElement)
          break;

        case "returnedStopTimer":
          let timerServerIDStop = data.msg.timerServerID;
          let shouldStartStop = data.msg.shouldStart;
          let ELMxIDStop = data.msg.ELMxID;
          let serverTimeStop = data.msg.serverTime;
          let ascendingTimeStop = data.msg.ascendingTime;
          // let timerElement = document.querySelector(`[data-id='${timerServerID}']`);
          let timerElementStop = document.getElementById(timerServerIDStop);

          //stopTimer(data);
          console.log("returnedStopTimer:" + timerServerIDStop + " " + JSON.stringify(timerElementStop));
          if (timerElementStop) {


            console.log("Returning from server to stop timer on brower");
            let localTimerIDStop = allTimersByServerID[timerServerIDStop]
            let localAscendingTimerIDStop = allAscendingTimersByServerID[timerServerIDStop]
            console.log("localTimerIDStop:" + localTimerIDStop + " " + JSON.stringify(allTimersByServerID));
            clearInterval(localTimerIDStop);
            clearInterval(localAscendingTimerIDStop);
            delete allTimersByServerID[timerServerIDStop];
            delete allAscendingTimersByServerID[timerServerIDStop];
            let startPauseBtnStop = document.querySelector(`[data-id="${timerServerIDStop}-5"]`)
            startPauseBtnStop.textContent = "‚ñ∂Ô∏è";  // Change button text to 'Play' or 'Start'
            console.log("stopTimer by running out and setting orange:" + serverTimeStop);
            if (serverTimeStop <= 0) {
              console.log("stopTimer2 by running out and setting orange:" + serverTimeStop);
              timerElementStop.style.backgroundColor = "orange";
            } else {
              timerElementStop.style.backgroundColor = "";  // Reset background color
            }//end 
            startPauseBtnStop.dataset.status = "currently_paused";

          }//end timerElementStop
          break;

        case "returntoservervote":
          console.log("Vote update from server:", data);

          if (!data.id) {
            console.warn("‚ö†Ô∏è Missing ID in server response:", data);
            return;
          }

          // Find all elements with the matching data-id across tabs
          const voteDisplays = document.querySelectorAll(`[data-id='${data.id}']`);

          if (voteDisplays.length > 0) {
            voteDisplays.forEach((voteDisplay) => {
              // If the server sends "added", set button to unvote
              if (data.msg.includes("added")) {
                voteDisplay.textContent = "UnVote";
                voteDisplay.style.backgroundColor = "green";  // Set background to green for unvote
              }
              // If the server sends "removed", set button back to vote
              else if (data.msg.includes("removed")) {
                voteDisplay.textContent = "Vote";
                voteDisplay.style.backgroundColor = "";  // Reset background color
              }
            });
          } else {
            console.warn(`‚ö†Ô∏è No element found for data-id '${data.id}'`);
          }
          break;



        case "returnedFromServerUpdateVoteButton":
          console.log("Received update from server for vote button:", data);

          let voteButtonID = data.msg.voteButtonID;
          let isEnabled = data.msg.isEnabled;

          // Find the vote button using the ID
          let voteButton = document.querySelector(`.vote-btn[data-id='${voteButtonID}']`);

          if (voteButton) {
            if (isEnabled) {
              voteButton.classList.remove('disabled');
              voteButton.disabled = false;
            } else {
              voteButton.classList.add('disabled');
              voteButton.disabled = true;
            }
          } else {
            console.error(`Vote button with ID ${voteButtonID} not found.`);
          }
          break;



        case "returnedFromServerSetVetoUserId":
          console.log("Received set veto user data:", JSON.stringify(data.msg));

          const setVetoName = data.msg.vetoNewName;
          const setVetoElementID = data.msg.vetoElementID;
          const newtimeruserid = data.msg.newTimerUserID;
          console.log("newtimeruserid:", newtimeruserid);

          console.log("setVetoElementID:", setVetoElementID);

          const setVetoInputField = document.querySelector(`[data-id="${setVetoElementID}"]`);
          console.log("Updating field for set veto:", setVetoName, "Element:", setVetoInputField);

          if (setVetoInputField) {
            setVetoInputField.value = setVetoName;
          }
          break;

        case "returnedFromServerUpdateMultipleVetoValue":
          // console.log("testing my scric:", JSON.stringify(data.msg));

          // let vetoMultipleName = data.msg.vetoNewName;
          // let vetoMultipleElementID = data.msg.vetoElementID;
          // console.log("vetoElementID:" + vetoMultipleElementID);

          // const vetoMupltipleInputField = document.querySelector(`[data-id="${vetoMultipleElementID}"]`); // Select the veto input field

          // console.log("deleted ddd:" + vetoMultipleName + " element" + JSON.stringify(vetoMupltipleInputField));

          // if (vetoMupltipleInputField) {
          //   vetoMupltipleInputField.value = vetoMultipleName;
          // }

          console.log("testing my scric:", JSON.stringify(data.msg));
          console.log("Received update from server:", data.msg);

          const vetoMultipleName = data.msg.vetoNewName;
          const vetoMultipleElementID = data.msg.vetoElementID;
          console.log("vetoElementID:", vetoMultipleElementID);

          const vetoMupltipleInputField = document.querySelector(`[data-id="${vetoMultipleElementID}"]`);
          console.log("deleted ddd:", vetoMultipleName + " element", JSON.stringify(vetoMupltipleInputField));

          if (vetoMupltipleInputField) {
            // Update input field only if new veto name differs from current
            if (vetoMupltipleInputField.value !== vetoMultipleName) {
              vetoMupltipleInputField.value = vetoMultipleName;
            }
          }
          break;







        case "returnedFromServerSubmenuClick":
          console.log("Testing what is this first data:", data.msg.timerFromNewName);

          const { timerServerDropdownID, clickedButton, formButtonID, timerDropdownID, clickCount, timerFromNewName, newtimerinputfiled } = data.msg;
          console.log("Testing what is this data:", data.msg);
          console.log("Testing what is this newtimerinputfiled:", data.msg.newtimerinputfiled);

          // Retrieve previous selections from localStorage (track per formButtonID)
          let previousSelections = JSON.parse(localStorage.getItem("previousSelections")) || {};

          // Reset only the previously selected elements for the same formButtonID
          if (previousSelections[formButtonID]) {
            const prevSelection = previousSelections[formButtonID];

            // Reset background only for the previously selected submenu item
            if (prevSelection.timerServerDropdownID) {
              document.querySelectorAll(`.submenu-item[data-timerServerID="${prevSelection.timerServerDropdownID}"]`).forEach(button => {
                button.style.backgroundColor = "";
              });
            }

            // Reset background only for the previously selected dropdown item
            if (prevSelection.timerDropdownID) {
              document.querySelectorAll(`.dropdown-item[data-timer-id="${prevSelection.timerDropdownID}"]`).forEach(parentButton => {
                parentButton.style.backgroundColor = "";
              });
            }

            // Reset background only for the previously selected form button
            if (prevSelection.formButtonID) {
              document.querySelectorAll(`.form-btn[data-id="${prevSelection.formButtonID}"]`).forEach(formBtn => {
                formBtn.style.backgroundColor = "";
              });
            }
          }

          // Update new selection (change background color only for the newly selected elements)
          document.querySelectorAll(`.submenu-item[data-timerServerID="${timerServerDropdownID}"]`).forEach(button => {
            button.style.backgroundColor = "green"; // Highlight clicked submenu button
          });

          document.querySelectorAll(`.dropdown-item[data-timer-id="${timerDropdownID}"]`).forEach(parentButton => {
            parentButton.style.backgroundColor = "green"; // Highlight correct parent dropdown item
          });

          document.querySelectorAll(`.form-btn[data-id="${formButtonID}"]`).forEach(formBtn => {
            formBtn.style.backgroundColor = "green"; // Highlight correct form button
          });

          // Save the current selection **per formButtonID**
          previousSelections[formButtonID] = {
            timerServerDropdownID,
            timerDropdownID,
            formButtonID
          };

          localStorage.setItem("previousSelections", JSON.stringify(previousSelections));

          // Sync changes across tabs
          localStorage.setItem("backgroundSync", Date.now());

          // Update the click count display
          updateClickCountDisplay(timerServerDropdownID, clickCount, timerFromNewName, formButtonID, newtimerinputfiled);
          sendTimerUpdate(timerServerDropdownID);
          break;



        case "returnedContentDropdownClick":
          console.log("Received returnedContentDropdownClick response:", data.msg);

          const {
            selectedContent,
            timerID,
            topicName,
            topicTime,
            count // Optional: how many times this was selected
          } = data.msg;

          console.log("Processed returned content data:", data.msg);

          // Track previous selections (only needed if you want to un-highlight old ones)
          if (!window.previousContentSelections) {
            window.previousContentSelections = {};
          }

          // Reset old selection highlight
          if (window.previousContentSelections[timerID]) {
            document.querySelectorAll(`.dropdown-item[data-type="${window.previousContentSelections[timerID]}"]`).forEach(button => {
              button.style.backgroundColor = "";
            });
          }

          // Highlight newly selected item
          document.querySelectorAll(`.dropdown-item[data-type="${selectedContent}"]`).forEach(button => {
            button.style.backgroundColor = "brown";
          });

          // Highlight the button itself
          document.querySelectorAll(`.content-btn[data-id="${timerID}"]`).forEach(contentBtn => {
            contentBtn.style.backgroundColor = "brown";
          });

          // Update previous selection memory
          window.previousContentSelections[timerID] = selectedContent;

          // Optional: Show selected content somewhere
          const selectedContentDisplay = document.getElementById("selected-content-display");
          if (selectedContentDisplay) {
            selectedContentDisplay.textContent = `Selected: ${selectedContent} ‚Üí "${topicName}" for ${topicTime}`;
          }

          // Optional: Show click count (if you‚Äôre tracking)
          if (typeof updateContentClickCountDisplay === "function") {
            updateContentClickCountDisplay(selectedContent, timerID, topicName, topicTime, count);
          }

          break;





        case "returnedPeopleDropdownClick":
          console.log("Received peopleDropdownClick response:", data.msg);

          const { selectedAction, buttonID, buttonPeopleText, timerPeopleNewName } = data.msg;

          console.log("Processed data:", data.msg);

          if (!window.previousPeopleSelections) {
            window.previousPeopleSelections = {};
          }

          if (window.previousPeopleSelections[buttonID]) {
            document.querySelectorAll(`.dropdown-item[data-action="${window.previousPeopleSelections[buttonID]}"]`).forEach(button => {
              button.style.backgroundColor = "";
            });
          }

          document.querySelectorAll(`.dropdown-item[data-action="${selectedAction}"]`).forEach(button => {
            button.style.backgroundColor = "green";
          });

          document.querySelectorAll(`.people-btn[data-id="${buttonID}"]`).forEach(peopleBtn => {
            peopleBtn.style.backgroundColor = "brown";
          });

          window.previousPeopleSelections[buttonID] = selectedAction;

          // Update the displayed selection
          const selectedPeopleDisplay = document.getElementById("selected-people-display");
          if (selectedPeopleDisplay) {
            selectedPeopleDisplay.textContent = `Selected: ${buttonPeopleText}`;
          }

          // Update people selection count display
          updatePeopleClickCountDisplay(selectedAction, buttonID, buttonPeopleText, timerPeopleNewName);

          break;





        case "donateTimeResult":
          const {
            fromUserID,
            toUserID,
            timerName,
            donatedMinutes,
            donatedSeconds,
            totalSeconds,
            donorNewTime,
            recipientNewTime,
            recipientName,
            donorName,
            approvedByID,
            approvedByName,
            donationCount // üëà Get the count directly from server response
          } = data.msg;

          // ‚õî Prevent self-donation
          if (fromUserID === toUserID) {
            const errorMsg = `‚ùå Invalid donation: You cannot donate time to yourself (${donorName || fromUserID}).`;
            console.warn(errorMsg);
            displayDonationMessageOnHTML(errorMsg, true);
            break;
          }

          const isRepeated = donationCount > 1; // ‚úÖ Use count from backend

          // üßæ Build donation message
          let donationMessage = `${timerName || "Timer"} Donated ${donatedMinutes}m ${donatedSeconds}s to ${recipientName || toUserID}`;

          if (donationCount > 1) {
            donationMessage += ` (Donated ${donationCount} ${donationCount === 1 ? "time" : "times"})`;
          }

          // ‚úÖ If there's an approver, append their info
          if (approvedByID && approvedByName) {
            donationMessage += ` ‚úÖ Approved by ${approvedByName}`;
          }

          // Loop iteration for the messages (Add a counter here)
          const donationIndex = donationCount; // You can replace this with the iteration variable if needed

          console.log(`Entry ${donationIndex}: ${donationMessage}`);
          displayDonationMessageOnHTML(`${donationIndex}. ${donationMessage}`, false, isRepeated);

          // ‚è±Ô∏è Update timers
          updateTimerDisplay(fromUserID, donorNewTime);
          updateTimerDisplay(toUserID, recipientNewTime);

          break;





        default:
          console.log('Unrecognized command:', data.cmd);
          break;











        case 'voteCountReturned':

          break;



          // Update UI elements dynamically
          document.getElementById("mainTimer").value = data.mainTimer;
          document.getElementById("voteData").textContent = `Total Votes: ${data.totalVotes}`;
          document.getElementById("individualCount").innerText = data.counters.Individual;
          document.getElementById("particularCount").innerText = data.counters.Particular;
          document.getElementById("universalCount").innerText = data.counters.Universal;
      }//end MAIN SWITCH/SWITCH MAIN

    };//end socket.message





    /////////////////////////////////////////////////////////////////
    let workerDispatch = (cmd, msg) => {
      console.log("WorkerDispatch cmd:" + cmd);
      switch (cmd) {
        case 'getNewAWSCreds':
          console.log("Getting workerDispatch awsCres");
          //worker.postMessage({'cmd': 'getNewAWSCreds', 'msg': msg});
          break;
      }//end cmd 
    };//end workerDispatch

    socket.onclose = function () {
      console.log("Disconnected from WebSocket server. Reconnecting...");
      setTimeout(() => {
        location.reload();
      }, 2000);
    };

    socket.onerror = function (error) {
      console.error("WebSocket Error:", error);
    };

    // Function to send updated timer data to WebSocket server




    function updateTimerDisplay(userID, newTimeInSeconds) {
      const elementID = `${userID}-2`;  // The ID for the user's timer input field (assuming format like "userID-2")
      const timerInputField = document.querySelector(`[data-id="${elementID}"]`);

      if (timerInputField) {
        // Format the time as mm:ss (no milliseconds)
        let minutes = Math.floor(newTimeInSeconds / 60);
        let seconds = Math.floor(newTimeInSeconds % 60);
        seconds = seconds < 10 ? "0" + seconds : seconds;  // Add leading zero to seconds if less than 10

        const formattedTime = `${minutes}:${seconds}`;

        // Replace the old timer value with the formatted time
        timerInputField.value = formattedTime; // Update the input field with the new time

        console.log(`‚è≥ Updated timer for user ${userID}: ${formattedTime}`);

        // Find the running timer for the user and update it
        if (allTimersByServerID[userID]) {
          // Clear the previous interval (if any)
          clearInterval(allTimersByServerID[userID]);
          delete allTimersByServerID[userID];

          // Set the new time to the timer
          let totalSeconds = newTimeInSeconds;

          // Start a new interval to continue from the updated time
          allTimersByServerID[userID] = setInterval(() => {
            if (totalSeconds <= 0) {
              clearInterval(allTimersByServerID[userID]);
              delete allTimersByServerID[userID];
              console.log("‚è∞ Timer finished for user", userID);
              return;
            }

            totalSeconds--;  // Decrease the time
            let updatedMinutes = Math.floor(totalSeconds / 60);
            let updatedSeconds = Math.floor(totalSeconds % 60);
            updatedSeconds = updatedSeconds < 10 ? "0" + updatedSeconds : updatedSeconds;

            // Update the display with the new time (formatted as mm:ss)
            timerInputField.value = `${updatedMinutes}:${updatedSeconds}`;
          }, 1000);  // Update every second (no milliseconds displayed)
        }
      } else {
        console.error(`‚ùå Timer input field not found for user ${userID}.`);
      }
    }




  </script>


  <script>
    let timerList = "initialize";//we can't load these with getElementID because DOMContentLoaded not loaded yet
    let addTimerBtn = "initialize"; // see setGlobalVariablesOnceDOMContentLoaded which sets them once DOM is loaded
    let defaultTimeInput = "initialize";
    let notifyCheckbox = "initialize";
    let voteDataDiv = "initialize";
    let contentDisplayContainer = "initialize";
    console.log("DOMContentLoaded: timerList:" + JSON.stringify(timerList));
    let totalVotes = 0; // Global vote count to track total votes
    let currentRunningTimer = null; // Track the currently running timer
    let allTimersByServerID = {};//form {"serverIDOfTimer": setIntervalID} we need this for clearInterval particularly if multiple timers running
    let allAscendingTimersByServerID = {};

    const counters = {//used in updateCounterDisplay
      Individual: 0,
      Particular: 0,
      Universal: 0
    };

    function setGlobalVariablesOnceDOMContentLoaded() {
      timerList = document.getElementById("timerList");
      addTimerBtn = document.getElementById("addTimerBtn");
      defaultTimeInput = document.getElementById("defaultTime");
      notifyCheckbox = document.getElementById("notifyCheckbox");
      voteDataDiv = document.getElementById("voteData"); // Total vote di
      contentDisplayContainer = document.getElementById("contentDisplayContainer");

    }//end setGlobalVariablesOnceDOMContentLoaded

    function synchronizeScreenDraw() {
      //this function is called once DOMContentLoaded loads to go to server and then draw all DOM elemtns and timers.
      //we must wait to call this because the websocket starts before DOM is loaded and will give error. 
      //we must load websocket and then DOM and then this function

      const timerList = document.getElementById("timerList");
      const addTimerBtn = document.getElementById("addTimerBtn");
      const defaultTimeInput = document.getElementById("defaultTime");
      const notifyCheckbox = document.getElementById("notifyCheckbox");
      const voteDataDiv = document.getElementById("voteData"); // Total vote display

      const contentDisplayContainer = document.getElementById("contentDisplayContainer");
      console.log("DOMContentLoaded: timerList:" + JSON.stringify(timerList));



      let totalVotes = 0; // Global vote count to track total votes
      let currentRunningTimer = null; // Track the currently running timer

      addTimerBtn.style.color = "green"; // Optional: Set the color to green




      addTimerBtn.addEventListener("click", addTimer);


      notifyCheckbox.addEventListener("change", function () {
        if (this.checked) {
          requestNotificationPermission();
        }
      });

      // addTimerBtn.addEventListener("click", addTimer);
      resetVotesBtn.addEventListener("click", resetVotes); // Add listener for reset vote button

    };//end  synchronizeScreenDraw();




    let resetCycleCompleted = false; // Tracks if the first reset cycle has been completed

    function resetVotes() {
      console.log("In resetVotes (with colours)");

      // Save voterMap data for fallback purposes
      const savedVoterMap = { ...voterMap };

      // Reset vote tracking data
      clickCountsMap = {};
      formButtonSelections = {};
      alreadyClicked = {};
      newtimerinputfiledMap = {}; // Include this if needed
      manageValuesMap = {};       // Include this if needed

      // Ensure fallback data (e.g., "nobody") is preserved in voterMap
      voterMap = {};
      // voterMap = savedVoterMap;

      // Reset total vote count display
      totalVotes = 0;
      voteDataDiv.textContent = `Total Votes: ${totalVotes}`;

      // Reset vote buttons
      document.querySelectorAll(".vote-btn").forEach(voteBtn => {
        voteBtn.style.backgroundColor = "";
        voteBtn.textContent = "Vote";
        voteBtn.setAttribute("data-voted", "false");
        voteBtn.disabled = true;
      });

      // Reset content buttons
      document.querySelectorAll(".content-btn").forEach(contentBtn => {
        contentBtn.style.backgroundColor = "";
        contentBtn.setAttribute("data-voted", "false");
        contentBtn.disabled = false;
      });

      // Reset the background color for all people buttons
      document.querySelectorAll(".people-btn").forEach(peopleBtn => {
        peopleBtn.style.backgroundColor = "";
      });

      // Reset localStorage
      localStorage.removeItem("previousSelections");

      // Clear UI vote list
      const clickCountsList = document.getElementById("click-counts-list");
      clickCountsList.innerHTML = '';

      // Reset dropdowns
      resetDropdownButtons();

      // Notify other tabs
      localStorage.setItem("voteReset", Date.now());



      // // Get all timerServerID values from timer elements
      // const timerServerIDs = Array.from(document.querySelectorAll("[data-timerServerID]"))
      //   .map(timer => timer.getAttribute("data-timerServerID"));

      // console.log("Timer Server IDs:", timerServerIDs); // Logs all timer server IDs


      // Get all timerServerID values from timer elements
      const timerServerIDs = Array.from(document.querySelectorAll("[data-timerServerID]"))
        .map(timer => timer.getAttribute("data-timerServerID"));

      // Group timer IDs by their prefixes (1, 2, 3, etc.)
      const groupedIDs = {};

      timerServerIDs.forEach(id => {
        const prefix = id.split('-')[0]; // Extract the prefix (1, 2, 3, etc.)
        if (!groupedIDs[prefix]) {
          groupedIDs[prefix] = [];
        }
        groupedIDs[prefix].push(id);
      });

      console.log("Grouped Timer Server IDs:", groupedIDs);


      // Send update via WebSocket
      // sendTimerUpdate(timerServerIDs);
      // Set the reset flag (only the first time)
      if (!resetCycleCompleted) {
        console.log("First reset cycle completed.");
        resetCycleCompleted = true;
        // First-time logic (message/tutorial)
      } else {
        console.log("Subsequent reset cycle triggered.");
        // Handle any reset behavior for subsequent cycles
      }
    }



    // let vetoClickCountMap = {}; // Store click count for each timerID

    // document.getElementById('resetVotesBtn').addEventListener('click', sendTimerUpdateFromButton);

    // function sendTimerUpdateFromButton() {
    //   console.log("Sending veto name updates...");

    //   const vetoInputs = document.querySelectorAll('[data-id$="-4"]');
    //   const oldVetoMap = {}; // { newTimerID: oldVetoValue }

    //   // STEP 1: Capture old veto values
    //   vetoInputs.forEach(input => {
    //     const dataId = input.getAttribute('data-id'); // e.g., "3-4"
    //     const newTimerID = dataId.split('-')[0];
    //     const oldVetoValue = input.value;
    //     oldVetoMap[newTimerID] = oldVetoValue;
    //     console.log(`Existing -> newTimerID: ${newTimerID}, Old Veto Value: ${oldVetoValue}`);
    //   });


    //   // STEP 2: Determine highest voted option
    //   let highestVoteCount = 0;
    //   let highestVotedName = "";
    //   for (let [key, count] of Object.entries(clickCountsMap)) {
    //     if (count > highestVoteCount) {
    //       highestVoteCount = count;
    //       highestVotedName = key;
    //     }
    //   }

    //   if (!highestVotedName) {
    //     alert("No votes to select for veto.");
    //     return;
    //   }

    //   const selectedVeto = document.querySelector(`input[name="vetoSelection"][value="${highestVotedName}"]`);
    //   if (!selectedVeto) {
    //     alert("Selected veto option not found.");
    //     return;
    //   }

    //   const vetoValue = selectedVeto.value;
    //   console.log("Selected veto value:", vetoValue);

    //   // STEP 3: Log vote breakdown
    //   for (let [key, count] of Object.entries(clickCountsMap)) {
    //     if (count > 0) {
    //       const voters = voterMap[key] ? voterMap[key].join(", ") : "Unknown";
    //       const manageValueForKey = manageValuesMap[key] || "N/A";
    //       const newTimerInputs = Object.values(newtimerinputfiledMap[key] || {}).join(", ") || "No input provided";

    //       console.log(`Votes Data  : (${voters}) voted for (${key}) For: (${newTimerInputs}) min. Total Votes: ${count}`);
    //     }
    //   }

    //   // STEP 4: Apply new veto values and send to server
    //   vetoInputs.forEach(input => {
    //     const vetoElementID = input.getAttribute('data-id');
    //     const newTimerID = vetoElementID.split('-')[0];
    //     const oldVetoValue = oldVetoMap[newTimerID];

    //     console.log("newTimerID from", newTimerID);

    //     // Init click count for this timer if missing
    //     if (!vetoClickCountMap[newTimerID]) {
    //       vetoClickCountMap[newTimerID] = 0;
    //     }

    //     let vetoMessage;
    //     if (oldVetoValue === vetoValue) {
    //       vetoMessage = `f-${vetoClickCountMap[newTimerID]}`;
    //       console.log(`Repeated sentence for newTimerID: ${newTimerID}. Passing previous value: ${vetoMessage}`);
    //     } else {
    //       vetoClickCountMap[newTimerID] += 1;
    //       vetoMessage = `f-${vetoClickCountMap[newTimerID]}`;
    //     }

    //     input.value = vetoMessage;

    //     const responseObject = {
    //       cmd: "updateMultipleVetoValue",
    //       msg: {
    //         ELMxID: 0,
    //         vetoMultipleNewTimerId: newTimerID,
    //         vetoElementID: vetoElementID,
    //         vetoNewName: vetoMessage
    //       }
    //     };

    //     console.log("Sending responseObject to server:", responseObject);
    //     socket.send(JSON.stringify(responseObject));
    //   });

    //   console.log("‚úÖ Veto value update process complete.");
    // }

    //working code

    // let vetoClickCountMap = {}; // Store click count for each timerID

    // document.getElementById('resetVotesBtn').addEventListener('click', sendTimerUpdateFromButton);

    // function sendTimerUpdateFromButton() {
    //   console.log("Sending veto name updates...");

    //   const vetoInputs = document.querySelectorAll('[data-id$="-4"]');
    //   const oldVetoMap = {}; // { newTimerID: oldVetoValue }

    //   // STEP 1: Capture old veto values
    //   vetoInputs.forEach(input => {
    //     const dataId = input.getAttribute('data-id'); // e.g., "3-4"
    //     const newTimerID = dataId.split('-')[0];
    //     const oldVetoValue = input.value;
    //     oldVetoMap[newTimerID] = oldVetoValue;
    //     console.log(`Existing -> newTimerID: ${newTimerID}, Old Veto Value: ${oldVetoValue}`);
    //   });

    //   // STEP 2: Determine highest voted option
    //   let highestVoteCount = 0;
    //   let highestVotedName = "";
    //   for (let [key, count] of Object.entries(clickCountsMap)) {
    //     if (count > highestVoteCount) {
    //       highestVoteCount = count;
    //       highestVotedName = key;
    //     }
    //   }

    //   if (!highestVotedName) {
    //     alert("No votes to select for veto.");
    //     return;
    //   }

    //   const selectedVeto = document.querySelector(`input[name="vetoSelection"][value="${highestVotedName}"]`);
    //   if (!selectedVeto) {
    //     alert("Selected veto option not found.");
    //     return;
    //   }

    //   const vetoValue = selectedVeto.value;
    //   console.log("Selected veto value:", vetoValue);

    //   // STEP 3: Log vote breakdown
    //   for (let [key, count] of Object.entries(clickCountsMap)) {
    //     if (count > 0) {
    //       const voters = voterMap[key] ? voterMap[key].join(", ") : "Unknown";
    //       const manageValueForKey = manageValuesMap[key] || "N/A";
    //       const newTimerInputs = Object.values(newtimerinputfiledMap[key] || {}).join(", ") || "No input provided";

    //       console.log(`Votes Data  : (${voters}) voted for (${key}) For: (${newTimerInputs}) min. Total Votes: ${count}`);
    //     }
    //   }

    //   // STEP 4: Apply new veto values and send to server
    //   vetoInputs.forEach(input => {
    //     const vetoElementID = input.getAttribute('data-id');
    //     const newTimerID = vetoElementID.split('-')[0];
    //     const oldVetoValue = oldVetoMap[newTimerID];

    //     console.log("newTimerID from", newTimerID);

    //     // Init click count for this timer if missing
    //     if (!vetoClickCountMap[newTimerID]) {
    //       vetoClickCountMap[newTimerID] = 0;
    //     }

    //     let vetoMessage;
    //     if (oldVetoValue === vetoValue) {
    //       vetoMessage = `f-${vetoClickCountMap[newTimerID]}`;
    //       console.log(`Repeated sentence for newTimerID: ${newTimerID}. Passing previous value: ${vetoMessage}`);
    //     } else {
    //       vetoClickCountMap[newTimerID] += 1;
    //       vetoMessage = `f-${vetoClickCountMap[newTimerID]}`;
    //     }

    //     input.value = vetoMessage;

    //     const responseObject = {
    //       cmd: "updateMultipleVetoValue",
    //       msg: {
    //         ELMxID: 0,
    //         vetoMultipleNewTimerId: newTimerID,
    //         vetoElementID: vetoElementID,
    //         vetoNewName: vetoMessage,
    //         oldVetoName: oldVetoValue // ‚úÖ Send old veto value
    //       }
    //     };

    //     console.log("Sending old veto:", responseObject);
    //     socket.send(JSON.stringify(responseObject));
    //   });

    //   console.log("‚úÖ Veto value update process complete.");
    // }


    let vetoClickCountMap = {}; // Store click count for each timerID

    document.getElementById('resetVotesBtn').addEventListener('click', sendTimerUpdateFromButton);

    function sendTimerUpdateFromButton() {
      console.log("Sending veto name updates...");

      const vetoInputs = document.querySelectorAll('[data-id$="-4"]');
      const oldVetoMap = {}; // { newTimerID: oldVetoValue }

      // STEP 1: Capture old veto values
      vetoInputs.forEach(input => {
        const dataId = input.getAttribute('data-id'); // e.g., "3-4"
        const newTimerID = dataId.split('-')[0];
        const oldVetoValue = input.value;
        oldVetoMap[newTimerID] = oldVetoValue;
        console.log(`Existing -> newTimerID: ${newTimerID}, Old Veto Value: ${oldVetoValue}`);
      });

      // STEP 2: Determine highest voted option
      let highestVoteCount = 0;
      let highestVotedName = "";
      for (let [key, count] of Object.entries(clickCountsMap)) {
        if (count > highestVoteCount) {
          highestVoteCount = count;
          highestVotedName = key;
        }
      }

      if (!highestVotedName) {
        alert("No votes to select for veto.");
        return;
      }

      const selectedVeto = document.querySelector(`input[name="vetoSelection"][value="${highestVotedName}"]`);
      if (!selectedVeto) {
        alert("Selected veto option not found.");
        return;
      }

      const vetoValue = selectedVeto.value;
      console.log("Selected veto value:", vetoValue);

      // STEP 3: Log vote breakdown
      for (let [key, count] of Object.entries(clickCountsMap)) {
        if (count > 0) {
          const voters = voterMap[key] ? voterMap[key].join(", ") : "Unknown";
          const manageValueForKey = manageValuesMap[key] || "N/A";
          const newTimerInputs = Object.values(newtimerinputfiledMap[key] || {}).join(", ") || "No input provided";

          console.log(`Votes Data  : (${voters}) voted for (${key}) For: (${newTimerInputs}) min. Total Votes: ${count}`);
        }
      }

      // STEP 4: Apply new veto values and send to server
      vetoInputs.forEach(input => {
        const vetoElementID = input.getAttribute('data-id');
        const newTimerID = vetoElementID.split('-')[0];
        const oldVetoValue = oldVetoMap[newTimerID];

        console.log("newTimerID from", newTimerID);

        // If old value is null or empty, skip assigning f-1 etc.
        if (oldVetoValue === null || oldVetoValue === "") {
          input.value = ""; // Leave it blank/null
          console.log(`Skipping veto update for newTimerID: ${newTimerID} since oldVetoValue is null/empty`);

          const responseObject = {
            cmd: "updateMultipleVetoValue",
            msg: {
              ELMxID: 0,
              vetoMultipleNewTimerId: newTimerID,
              vetoElementID: vetoElementID,
              vetoNewName: null,
              oldVetoName: oldVetoValue
            }
          };

          socket.send(JSON.stringify(responseObject));
          return;
        }

        // Init click count for this timer if missing
        if (!vetoClickCountMap[newTimerID]) {
          vetoClickCountMap[newTimerID] = 0;
        }

        let vetoMessage;
        if (oldVetoValue === vetoValue) {
          vetoMessage = `f-${vetoClickCountMap[newTimerID]}`;
          console.log(`Repeated sentence for newTimerID: ${newTimerID}. Passing previous value: ${vetoMessage}`);
        } else {
          vetoClickCountMap[newTimerID] += 1;
          vetoMessage = `f-${vetoClickCountMap[newTimerID]}`;
        }

        input.value = vetoMessage;

        const responseObject = {
          cmd: "updateMultipleVetoValue",
          msg: {
            ELMxID: 0,
            vetoMultipleNewTimerId: newTimerID,
            vetoElementID: vetoElementID,
            vetoNewName: vetoMessage,
            oldVetoName: oldVetoValue
          }
        };

        console.log("Sending updated veto:", responseObject);
        socket.send(JSON.stringify(responseObject));
      });

      console.log("‚úÖ Veto value update process complete.");
    }




    function sendTimerUpdate(timerServerDropdownID) {
      console.log("Sending veto name updates...");
      console.log("timerServerDropdownID:", timerServerDropdownID);

      const savedVoterMap = { ...voterMap };
      console.log("savedVoterMap:", savedVoterMap);

      const userKey = Object.keys(voterMap)[0];
      console.log("userKey (selected):", userKey);

      const matches = timerServerDropdownID.match(/(\d+)-([a-zA-Z]+)/);
      let number = '';
      let string = '';

      if (matches) {
        number = matches[1];
        string = matches[2];
      }

      console.log("String:", string);

      if (!window.stringCounts) {
        window.stringCounts = {};
      }

      if (window.stringCounts[string]) {
        window.stringCounts[string]++;
      } else {
        window.stringCounts[string] = 1;
      }

      const count = window.stringCounts[string];
      let baseVetoMessage = `${string}`;

      const vetoInputs = document.querySelectorAll(`[data-id$='${number}-4']`);
      console.log("vetoInputs:", vetoInputs);

      vetoInputs.forEach(input => {
        const vetoElementID = input.getAttribute('data-id');
        console.log("vetoElementID:", vetoElementID);

        let vetoMessage = baseVetoMessage;


        input.value = vetoMessage;

        const responseObject = {
          cmd: "setVetoUserId",
          msg: {
            ELMxID: 0,
            newTimerID: number, // Ensure newTimerID is available in your context
            vetoElementID: vetoElementID,
            vetoNewName: vetoMessage
          }
        };

        console.log("Sending responseObject to server:", responseObject);
        socket.send(JSON.stringify(responseObject));
      });

      socket.send(JSON.stringify("Veto value updated and sent"));
      console.log("Veto value updated and sent to server.");
    }



















    // Listen for reset events from other tabs
    window.addEventListener("storage", (event) => {
      if (event.key === "voteReset") {
        console.log("Vote reset detected from another tab");
        resetVotes(); // Trigger reset in the current tab
      }
    });





    function resetDropdownButtons() {
      const buttons = document.querySelectorAll("#formbtn, .dropdown-item, .submenu-item");

      buttons.forEach(button => {
        button.style.backgroundColor = ""; // Reset background color for all buttons
      });
    }//end resetDropdownButtons




    function sendSystemNotification(title, options) {
      if ("Notification" in window && Notification.permission === "granted") {
        new Notification(title, options);
      } else if (Notification.permission === "denied") {
        Notification.requestPermission().then(permission => {
          if (permission === "granted") {
            new Notification(title, options);

          }
        });
      }
    }//end sendSystemNotification





    function requestNotificationPermission() {
      if ("Notification" in window) {
        Notification.requestPermission().then(permission => {
          if (permission === "granted") {
            console.log("Notification permission granted.");
          }
        });
      }
    } //requestNotificationPermission

    function setupTimerControls(timerComponent, initialTime) {
      const timerTitle = timerComponent.querySelector(".timer-title");
      const timerAsc = timerComponent.querySelector(".timer-asc");

      const timerValue = timerComponent.querySelector(".timer-value");
      const startPauseBtn = timerComponent.querySelector(".start-pause-btn");
      const resetInitialBtn = timerComponent.querySelector(".reset-initial-btn");
      const resetDefaultBtn = timerComponent.querySelector(".reset-default-btn");
      const removeBtn = timerComponent.querySelector(".remove-btn");
      let intervalId = null;
      let ascIntervalId = null;

      let wasRunning = false;
      let ascSeconds = 0;



      // Vote button functionality

      const voteBtn = timerComponent.querySelector(".vote-btn");
      const timerVoteID = voteBtn.getAttribute("data-id"); // Get dynamic data-id



      // Function to handle voting
      voteBtn.addEventListener("click", () => {
        let hasVoted = voteBtn.getAttribute("data-voted") === "true"; // Track vote per button

        if (!hasVoted) {
          // Increment total vote count (before sending to server)
          totalVotes++;
          voteBtn.setAttribute("data-voted", "true"); // Mark as voted
          voteBtn.textContent = "UnVote"; // Change text to UnVote
          voteBtn.style.backgroundColor = "green"; // Set background to green for voted button
          socket.send(JSON.stringify({ cmd: "addVote", msg: "Vote added", id: timerVoteID }));

          // Update totalVotes in localStorage (sync across all tabs)
          localStorage.setItem('totalVotes', totalVotes);
        } else {
          totalVotes = Math.max(0, totalVotes - 1); // Prevent negative votes
          voteBtn.setAttribute("data-voted", "false"); // Mark as unvoted
          voteBtn.textContent = "Vote"; // Reset text to Vote
          voteBtn.style.backgroundColor = ""; // Reset background color
          socket.send(JSON.stringify({ cmd: "removeVote", msg: "Vote Removed", id: timerVoteID }));

          // Update totalVotes in localStorage (sync across all tabs)
          localStorage.setItem('totalVotes', totalVotes);
        }

        // Update the vote count display (local tab update)
        voteDataDiv.textContent = `Total Votes: ${totalVotes}`;

        // Handle the reset vote button color based on percentage
        const votePercentage = numberCitizenTimers > 0 ? (totalVotes / numberCitizenTimers) * 100 : 0;

        // Update the votePercentage in localStorage to sync across tabs
        localStorage.setItem('votePercentage', votePercentage);

        // Update the resetVotesBtn color based on votePercentage
        const resetVotesBtn = document.getElementById("resetVotesBtn");

        if (votePercentage === 0) {
          resetVotesBtn.style.backgroundColor = 'black';
          resetVotesBtn.style.color = 'white';
        } else if (votePercentage < 10) {
          resetVotesBtn.style.backgroundColor = 'black';
          resetVotesBtn.style.color = 'white';
        } else if (votePercentage >= 10 && votePercentage < 70) {
          resetVotesBtn.style.backgroundColor = 'red';
          resetVotesBtn.style.color = 'black';
        } else if (votePercentage >= 70 && votePercentage < 100) {
          resetVotesBtn.style.backgroundColor = 'orange';
          resetVotesBtn.style.color = 'black';
        } else if (votePercentage === 100) {
          resetVotesBtn.style.backgroundColor = 'green';
          resetVotesBtn.style.color = 'black';
        }
      });

      // Listen for changes to totalVotes or votePercentage in localStorage (to sync across all tabs)
      window.addEventListener('storage', (e) => {
        if (e.key === 'totalVotes' || e.key === 'votePercentage') {
          const newVotePercentage = parseFloat(localStorage.getItem('votePercentage'));
          const resetVotesBtn = document.getElementById("resetVotesBtn");

          // Update the resetVotesBtn color based on the updated votePercentage
          if (newVotePercentage === 0) {
            resetVotesBtn.style.backgroundColor = 'black';
            resetVotesBtn.style.color = 'white';
          } else if (newVotePercentage < 10) {
            resetVotesBtn.style.backgroundColor = 'black';
            resetVotesBtn.style.color = 'white';
          } else if (newVotePercentage >= 10 && newVotePercentage < 70) {
            resetVotesBtn.style.backgroundColor = 'red';
            resetVotesBtn.style.color = 'black';
          } else if (newVotePercentage >= 70 && newVotePercentage < 100) {
            resetVotesBtn.style.backgroundColor = 'orange';
            resetVotesBtn.style.color = 'black';
          } else if (newVotePercentage === 100) {
            resetVotesBtn.style.backgroundColor = 'green';
            resetVotesBtn.style.color = 'black';
          }
        }
      });




      function toggleTimer(shouldStart) {
        if (shouldStart) {
          if (currentRunningTimer && currentRunningTimer !== timerComponent) {
            currentRunningTimer.querySelector(".start-pause-btn").click(); // Stop other timers
          }
          startTimer();
          startAscendingTimer();
        } else {
          clearInterval(intervalId);
          clearInterval(ascIntervalId);
          intervalId = null;
          ascIntervalId = null;
          startPauseBtn.textContent = "‚ñ∂Ô∏è";
          timerComponent.style.backgroundColor = "";
        }

        // Send update to the server
        const timerServerID = startPauseBtn.getAttribute("data-id");
        socket.send(JSON.stringify({
          cmd: "toggleTimer",
          msg: {
            ELMxID: 0,
            timerServerID: timerServerID,
            shouldStart: shouldStart,

          }
        }));

        console.log("Sent toggleTimer request to server:", timerServerID, shouldStart);
      }



      function startTimer() {
        // Clear background color when timer starts
        timerComponent.style.backgroundColor = "#c5eba9"; // Turn bg color to light green

        let [minutes, seconds] = timerValue.value.split(":").map(num => parseInt(num, 10));
        let totalSeconds = minutes * 60 + seconds;

        intervalId = setInterval(() => {
          if (totalSeconds <= 0) {
            clearInterval(intervalId);
            intervalId = null;
            timerComponent.style.backgroundColor = "orange";
            onComplete();
            startPauseBtn.textContent = "‚ñ∂Ô∏è";
            //stop the ascending timer when the count down reaches
            if (ascIntervalId) {
              clearInterval(ascIntervalId);
              ascIntervalId = null;
            }


            return;
          }
          totalSeconds--;

          const mins = Math.floor(totalSeconds / 60).toString();
          const secs = (totalSeconds % 60).toString().padStart(2, "0");
          timerValue.value = `${mins}:${secs}`;
        }, 1000);

        // currentRunningTimer = timerComponent; // Set the current running timer
        startPauseBtn.textContent = "‚è∏Ô∏è";
      }





      function startAscendingTimer() {
        let [ascMinutes, ascSecondsRaw] = timerAsc.value.split(":").map(num => parseInt(num, 10));
        ascSeconds = ascMinutes * 60 + ascSecondsRaw;

        ascIntervalId = setInterval(() => {
          ascSeconds++;
          const mins = Math.floor(ascSeconds / 60).toString();
          const secs = (ascSeconds % 60).toString().padStart(2, "0");
          timerAsc.value = `${mins}:${secs}`;
        }, 1000);
      }//end startAscendingTimer


      function stopTimerOnEdit(input) {
        input.addEventListener("focus", () => {
          if (intervalId !== null) {
            wasRunning = true;
            toggleTimer(false);
          }
        });

        input.addEventListener("blur", () => {
          if (wasRunning) {
            toggleTimer(true);
            wasRunning = false;
          }
        });
      }

      stopTimerOnEdit(timerValue);
      stopTimerOnEdit(timerAsc);


      timerValue.addEventListener("focus", () => {
        if (intervalId !== null) {
          wasRunning = true;
          toggleTimer(false);
        }
      });

      timerValue.addEventListener("blur", () => {
        if (wasRunning) {
          toggleTimer(true);
          wasRunning = false; // Reset the flag
        }
      });


      timerAsc.addEventListener("blur", () => {
        if (wasRunning) {
          toggleTimer(true);
          wasRunning = false; // Reset the flag
        }
      });

      resetDefaultBtn.addEventListener("click", () => {
        clearInterval(intervalId);
        clearInterval(ascIntervalId);

        intervalId = null;
        ascIntervalId = null;

        timerValue.value = document.getElementById("defaultTime"); //defaultTimeInput.value; // Reset to the current default time
        // timerValue.value = defaultTimeInput.value; // Reset to the current default time
        timerAsc.value = "00:00";
        ascSeconds = 0;

        timerComponent.style.backgroundColor = ""; // Remove background color
        startPauseBtn.textContent = "‚ñ∂Ô∏è";
      });

      resetInitialBtn.addEventListener("click", () => {
        clearInterval(intervalId);
        clearInterval(ascIntervalId);

        intervalId = null;
        ascIntervalId = null;
        timerAsc.value = "00:00";
        ascSeconds = 0;

        timerValue.value = initialTime; // Reset to the initial time
        timerComponent.style.backgroundColor = ""; // Remove background color
        startPauseBtn.textContent = "‚ñ∂Ô∏è";
      });

      // Assuming removeBtn is defined outside of the event listener.
      removeBtn.addEventListener("click", function () {
        // `this` refers to the button that was clicked (the one triggering the event)
        const clickedBtn = this; // Get the button clicked

        // Update the number of citizen timers
        numberCitizenTimers -= 1;
        document.getElementById("numberCitizenTimers").textContent = `Number Citizen Timers: ${numberCitizenTimers}`;

        const voteBtn = timerComponent.querySelector(".vote-btn"); // Make sure timerComponent is defined before
        const timerID = clickedBtn.getAttribute("data-id"); // Extract the timer ID from the clicked button

        console.log("HAS VOTED:" + (voteBtn.textContent === "Unvote"));
        console.log("voteBtn: ", voteBtn); // Check if the element is found
        console.log("voteBtn textContent: " + voteBtn.textContent);

        if (voteBtn.textContent === "Unvote") {
          console.log("HERE: " + (totalVotes - 1));
          totalVotes -= 1;
          voteDataDiv.textContent = `Total Votes: ${totalVotes}`; // Update the display
        }

        const resetVotesBtn = document.getElementById("resetVotesBtn");

        // Calculate the percentage of totalVotes compared to numberCitizenTimers
        const votePercentage = (totalVotes / numberCitizenTimers) * 100;
        console.log("VotePercentage Of Timers first:" + totalVotes + " " + numberCitizenTimers + " " + votePercentage);

        // Use a switch-case style logic to determine the button's color
        if (totalVotes == 0 && numberCitizenTimers == 0) {
          resetVotesBtn.style.backgroundColor = 'black';
          resetVotesBtn.style.color = 'white';
        } else if (votePercentage < 10) {
          resetVotesBtn.style.backgroundColor = 'black';
          resetVotesBtn.style.color = 'white';
        } else if (votePercentage >= 10 && votePercentage < 70) {
          resetVotesBtn.style.backgroundColor = 'red';
          resetVotesBtn.style.color = 'black';
        } else if (votePercentage >= 70 && votePercentage < 100) {
          resetVotesBtn.style.backgroundColor = 'orange';
          resetVotesBtn.style.color = 'black';
        } else if (votePercentage === 100) {
          resetVotesBtn.style.backgroundColor = 'green';
          resetVotesBtn.style.color = 'black';
        }


        // Prepare data to send to the server
        let responseObject = {
          cmd: "removeTimer",
          msg: {
            timerServerID: timerID,
            ELMxID: 0
          }
        };

        socket.send(JSON.stringify(responseObject));

        console.log("Sent removeTimer request to server:", responseObject);
      });


      function playSound() {
        const audio = new Audio("complete.mp3"); // Correct path to the sound file
        audio.play();
      }

      function onComplete() {
        playSound();
        // Check if system notifications are enabled and send a notification
        if (notifyCheckbox.checked) {
          sendSystemNotification(`${timerTitle.value || "Timer"} Completed`, {
            body: `Your ${timerTitle.value ? timerTitle.value + " " : ""}timer has finished.`,
          });
        }
      }
    }//end setupTimerControls

    // let clickCountsMap = {}; // Stores total votes for each name
    // let formButtonSelections = {}; // Maps formButtonID to its selected timerServerDropdownID
    // let voterMap = {}; // Stores list of voters for each name
    // let manageValuesMap = {}; // Stores "manage" input values for each vote
    // let newtimerinputfiledMap = {}; // Stores "newtimerinputfiled" for each voter
    // let alreadyClicked = {}; // Now an object instead of a Set

    // function updateClickCountDisplay(timerServerDropdownID, clickCount, timerFromNewName, formButtonID, newtimerinputfiled) {
    //   const clickCountsList = document.getElementById("click-counts-list");
    //   const name = timerServerDropdownID.split('-').slice(1).join('-');

    //   console.log("timerFromNewName: " + timerFromNewName);
    //   const manageInput = document.getElementById("manage");
    //   const manageValue = manageInput ? manageInput.value.trim() : "1:00"; // Default to "N/A" if input is not found

    //   // Ensure we track votes per user
    //   if (!alreadyClicked[timerFromNewName]) {
    //     alreadyClicked[timerFromNewName] = new Set();
    //   }



    //   // Check if this user has already voted for this option
    //   if (alreadyClicked[timerFromNewName].has(timerServerDropdownID)) {
    //     // Allow updating newtimerinputfiled even if already voted
    //     if (!newtimerinputfiledMap[name]) {
    //       newtimerinputfiledMap[name] = {};
    //     }
    //     newtimerinputfiledMap[name][timerFromNewName] = newtimerinputfiled;

    //     // Just refresh the display to show updated value
    //     updateClickCountDisplayList();
    //     // alert(`You have already voted for ${name}, but your time input was updated.`);
    //     return;
    //   }



    //   // If this formButtonID previously selected a different timerServerDropdownID, decrease its count
    //   if (formButtonSelections[formButtonID] && formButtonSelections[formButtonID] !== timerServerDropdownID) {
    //     const previousTimerServerDropdownID = formButtonSelections[formButtonID];
    //     const previousName = previousTimerServerDropdownID.split('-').slice(1).join('-');

    //     if (clickCountsMap[previousName]) {
    //       clickCountsMap[previousName] -= 1;

    //       // Remove the previous voter from the list
    //       if (voterMap[previousName]) {
    //         voterMap[previousName] = voterMap[previousName].filter(voter => voter !== timerFromNewName);
    //         if (voterMap[previousName].length === 0) {
    //           delete voterMap[previousName];
    //         }
    //       }

    //       if (clickCountsMap[previousName] <= 0) {
    //         delete clickCountsMap[previousName];
    //       }

    //       // Remove previous selection from alreadyClicked
    //       alreadyClicked[timerFromNewName].delete(previousTimerServerDropdownID);
    //     }
    //   }

    //   // Mark this selection for the formButtonID
    //   formButtonSelections[formButtonID] = timerServerDropdownID;

    //   // Increment vote count correctly
    //   clickCountsMap[name] = (clickCountsMap[name] || 0) + 1;

    //   // Store the voter's name
    //   if (!voterMap[name]) {
    //     voterMap[name] = [];
    //   }
    //   if (!voterMap[name].includes(timerFromNewName)) {
    //     voterMap[name].push(timerFromNewName);
    //   }

    //   // Store "manage" value for each vote
    //   manageValuesMap[name] = manageValue;

    //   // Store "newtimerinputfiled" for each vote (per voter)
    //   if (!newtimerinputfiledMap[name]) {
    //     newtimerinputfiledMap[name] = {};
    //   }
    //   newtimerinputfiledMap[name][timerFromNewName] = newtimerinputfiled;

    //   // Mark this vote in alreadyClicked
    //   alreadyClicked[timerFromNewName].add(timerServerDropdownID);
    //   // Clear and update display
    //   clickCountsList.innerHTML = '';
    //   for (let [key, count] of Object.entries(clickCountsMap)) {
    //     if (count > 0) {
    //       const voters = voterMap[key] ? voterMap[key].join(", ") : "Unknown";
    //       const manageValueForKey = manageValuesMap[key] || "N/A";

    //       // Now display each voter's "newtimerinputfiled" value
    //       const newTimerInputs = Object.values(newtimerinputfiledMap[key] || {}).join(", ") || "No input provided";

    //       // Create list item
    //       const listItem = document.createElement("li");

    //       // Create span for the text content
    //       const textSpan = document.createElement("span");
    //       textSpan.textContent = `(${voters}) voted for (${key}) For : (${newTimerInputs}) min`;

    //       // Append elements
    //       listItem.appendChild(textSpan);
    //       listItem.appendChild(document.createTextNode(` ${count} Vote${count > 1 ? 's' : ''}`));

    //       clickCountsList.appendChild(listItem);
    //     }
    //   }
    // }



    // function updateClickCountDisplayList() {
    //   const clickCountsList = document.getElementById("click-counts-list");
    //   clickCountsList.innerHTML = '';
    //   for (let [key, count] of Object.entries(clickCountsMap)) {
    //     if (count > 0) {
    //       const voters = voterMap[key] ? voterMap[key].join(", ") : "Unknown";
    //       const manageValueForKey = manageValuesMap[key] || "N/A";
    //       const newTimerInputs = Object.values(newtimerinputfiledMap[key] || {}).join(", ") || "No input provided";

    //       const listItem = document.createElement("li");
    //       const textSpan = document.createElement("span");
    //       textSpan.textContent = `(${voters}) voted for (${key}) For : (${newTimerInputs}) min`;
    //       listItem.appendChild(textSpan);
    //       listItem.appendChild(document.createTextNode(` ${count} Vote${count > 1 ? 's' : ''}`));
    //       clickCountsList.appendChild(listItem);
    //     }
    //   }
    // }


    let clickCountsMap = {}; // Stores total votes for each name
    let formButtonSelections = {}; // Maps formButtonID to its selected timerServerDropdownID
    let voterMap = {}; // Stores list of voters for each name
    let manageValuesMap = {}; // Stores "manage" input values for each vote
    let newtimerinputfiledMap = {}; // Stores "newtimerinputfiled" for each voter
    let alreadyClicked = {}; // Now an object instead of a Set

    function updateClickCountDisplay(timerServerDropdownID, clickCount, timerFromNewName, formButtonID, newtimerinputfiled) {
      const clickCountsList = document.getElementById("click-counts-list");
      const name = timerServerDropdownID.split('-').slice(1).join('-');

      const manageInput = document.getElementById("manage");
      const manageValue = manageInput ? manageInput.value.trim() : "1:00"; // Default to "N/A" if input is not found

      // Ensure we track votes per user
      if (!alreadyClicked[timerFromNewName]) {
        alreadyClicked[timerFromNewName] = new Set();
      }

      // Check if this user has already voted for this option
      if (alreadyClicked[timerFromNewName].has(timerServerDropdownID)) {
        if (!newtimerinputfiledMap[name]) {
          newtimerinputfiledMap[name] = {};
        }
        newtimerinputfiledMap[name][timerFromNewName] = newtimerinputfiled;

        updateClickCountDisplayList();
        return;
      }

      // If this formButtonID previously selected a different timerServerDropdownID, decrease its count
      if (formButtonSelections[formButtonID] && formButtonSelections[formButtonID] !== timerServerDropdownID) {
        const previousTimerServerDropdownID = formButtonSelections[formButtonID];
        const previousName = previousTimerServerDropdownID.split('-').slice(1).join('-');

        if (clickCountsMap[previousName]) {
          clickCountsMap[previousName] -= 1;

          if (voterMap[previousName]) {
            voterMap[previousName] = voterMap[previousName].filter(voter => voter !== timerFromNewName);
            if (voterMap[previousName].length === 0) {
              delete voterMap[previousName];
            }
          }

          if (clickCountsMap[previousName] <= 0) {
            delete clickCountsMap[previousName];
          }

          alreadyClicked[timerFromNewName].delete(previousTimerServerDropdownID);
        }
      }

      formButtonSelections[formButtonID] = timerServerDropdownID;
      clickCountsMap[name] = (clickCountsMap[name] || 0) + 1;

      if (!voterMap[name]) {
        voterMap[name] = [];
      }
      if (!voterMap[name].includes(timerFromNewName)) {
        voterMap[name].push(timerFromNewName);
      }

      manageValuesMap[name] = manageValue;

      if (!newtimerinputfiledMap[name]) {
        newtimerinputfiledMap[name] = {};
      }
      newtimerinputfiledMap[name][timerFromNewName] = newtimerinputfiled;

      alreadyClicked[timerFromNewName].add(timerServerDropdownID);



      clickCountsList.innerHTML = '';
      for (let [key, count] of Object.entries(clickCountsMap)) {
        if (count > 0) {
          const voters = voterMap[key] ? voterMap[key].join(", ") : "Unknown";
          const manageValueForKey = manageValuesMap[key] || "N/A";

          const newTimerInputValues = Object.values(newtimerinputfiledMap[key] || {});
          const newTimerInputs = newTimerInputValues.join(", ") || "No input provided";

          const totalTime = newTimerInputValues.reduce((sum, val) => {
            const num = parseFloat(val);
            return sum + (isNaN(num) ? 0 : num);
          }, 0);
          const totalVoters = voterMap[key] ? voterMap[key].length : 1;
          const dividedTime = totalTime / totalVoters;

          // Convert decimal minutes to MM:SS
          const minutes = Math.floor(dividedTime);
          const seconds = Math.round((dividedTime - minutes) * 60);
          const timeFormatted = `${minutes}:${seconds.toString().padStart(2, '0')}`;

          const listItem = document.createElement("li");
          const textSpan = document.createElement("span");
          textSpan.textContent = `(${voters}) voted for (${key}) For: (${newTimerInputs}) min, and the final time is (${timeFormatted})`;
          listItem.appendChild(textSpan);
          listItem.appendChild(document.createTextNode(` ${count} Vote${count > 1 ? 's' : ''}`));
          clickCountsList.appendChild(listItem);
        }
      }


    }
    //working 1
    function updateClickCountDisplayList() {
      const clickCountsList = document.getElementById("click-counts-list");
      clickCountsList.innerHTML = '';

      for (let [key, count] of Object.entries(clickCountsMap)) {
        if (count > 0) {
          const voters = voterMap[key] ? voterMap[key].join(", ") : "Unknown";
          const manageValueForKey = manageValuesMap[key] || "N/A";

          const newTimerInputValues = Object.values(newtimerinputfiledMap[key] || {});
          const newTimerInputs = newTimerInputValues.join(", ") || "No input provided";

          const totalTime = newTimerInputValues.reduce((sum, val) => {
            const num = parseFloat(val);
            return sum + (isNaN(num) ? 0 : num);
          }, 0);

          const totalVoters = voterMap[key] ? voterMap[key].length : 1;
          const dividedTime = totalTime / totalVoters;

          // Convert divided time to MM:SS format
          const minutes = Math.floor(dividedTime);
          const seconds = Math.round((dividedTime - minutes) * 60);
          const formattedTime = `${minutes}:${seconds.toString().padStart(2, '0')}`;

          const listItem = document.createElement("li");
          const textSpan = document.createElement("span");
          textSpan.textContent = `(${voters}) voted for (${key}) For: (${newTimerInputs}) min, and the final time is (${formattedTime})`;
          listItem.appendChild(textSpan);
          listItem.appendChild(document.createTextNode(` ${count} Vote${count > 1 ? 's' : ''}`));
          clickCountsList.appendChild(listItem);
        }
      }
    }






    function getTimersAsJson() {
      const timers = [];

      document.querySelectorAll(".timer").forEach(timerComponent => {
        const title = timerComponent.querySelector(".timer-title")?.value || "Untitled";
        const timeValue = timerComponent.querySelector(".timer-value")?.value || "00:00";
        const voteBtn = timerComponent.querySelector(".vote-btn");
        const hasVoted = voteBtn && voteBtn.textContent === "Unvote"; // Check if voted
        const assignedCategories = [...timerComponent.querySelectorAll(".dropdown-item.active")]
          .map(btn => btn.dataset.type); // Categories assigned

        timers.push({
          title: title,
          time: timeValue,
          voted: hasVoted,
          categories: assignedCategories.length > 0 ? assignedCategories : ["None"]
        });
      });

      const jsonOutput = JSON.stringify(timers, null, 2);
      console.log(jsonOutput); // Display in console
      return jsonOutput;
    }//end getTimersAsJson


    //addbutton



    //     let timerInitialized = false;

    // function initializeFirstTimer() {
    //   if (!timerInitialized) {
    //     addTimer(); // automatically calls it
    //     timerInitialized = true;
    //   }
    // }


    function addTimer() {

      // const defaultTime = defaultTimeInput.value || "00:30";
      const defaultTime = defaultTimeInput.value;
      const message = {
        cmd: 'addTimerToServer',
        msg: {
          defaultTime: defaultTime,//10:23
          ELMxID: 0, //this is hardcoded still as of Feb 17 2025
          // timerComponent: timerComponent.outerHTML // Pass the HTML of the timer component
        }
      };

      socket.send(JSON.stringify(message));

      console.log("testig k ho data " + JSON.stringify(message));

    }//end addTimer


    ////////Next Function (they must be in this order)

    function addContentSection(type, title, time) {
      const contentSection = document.createElement("div");
      contentSection.className = "content-section";

      let timerRunning = false;
      let timerInterval;
      let currentTime = time; // Save the original time for later use
      // <strong>${type}:</strong> ${title} - Time: <span class="time-display" contenteditable="true">${time}</span>

      contentSection.innerHTML = `
        <strong>${type} Added By : ${timerName} </strong> The Title Name is  ${title} - For : <span class="time-display" contenteditable="true">${time} Min</span>
        <button class="remove-content-btn">‚ùå</button>
      `;

      contentDisplayContainer.appendChild(contentSection);

      const removeContentBtn = contentSection.querySelector(".remove-content-btn");
      removeContentBtn.addEventListener("click", () => {
        contentSection.remove();
        counters[type]--;

        updateCounterDisplay();
      });

      const playPauseBtn = contentSection.querySelector(".play-pause-btn");
      const timeDisplay = contentSection.querySelector(".time-display");

      playPauseBtn.addEventListener("click", () => {
        if (timerRunning) {
          clearInterval(timerInterval);
          playPauseBtn.innerText = "‚ñ∂Ô∏è";
        } else {
          // When starting, get the time from the contenteditable element
          let editedTime = timeDisplay.innerText;
          let [minutes, seconds] = editedTime.split(":").map(Number);

          timerInterval = setInterval(() => {
            if (seconds > 0) {
              seconds--;
            } else if (minutes > 0) {
              minutes--;
              seconds = 59;
            } else {
              clearInterval(timerInterval);
            }
            editedTime = `${minutes}:${seconds < 10 ? "0" + seconds : seconds}`;
            timeDisplay.innerText = editedTime;
          }, 1000);
          playPauseBtn.innerText = "‚è∏Ô∏è";
        }
        timerRunning = !timerRunning;
      });
    }
    //end addContentSection





    let peopleClickCounts = {}; // Stores total selections for each action
    let peopleSelections = {}; // Maps buttonID to its selected action
    let peopleVoterMap = {}; // Stores list of voters per action

    function updatePeopleClickCountDisplay(selectedAction, buttonID, buttonPeopleText, timerPeopleNewName) {
      const peopleClickCountsList = document.getElementById("people-click-counts-list");
      const actionName = selectedAction; // Name of the selected action

      console.log(`Updating click count display for: ${actionName}, Timer Name: ${timerPeopleNewName}`);

      // Ensure we track voters per action (not per user)
      if (!peopleVoterMap[actionName]) {
        peopleVoterMap[actionName] = new Set();
      }

      // Prevent duplicate selection by the same user
      if (peopleVoterMap[actionName].has(timerPeopleNewName)) {
        alert(`"${timerPeopleNewName}" has already selected "${actionName}"!`);
        return;
      }

      // If this buttonID previously selected a different action, decrease its count
      if (peopleSelections[buttonID] && peopleSelections[buttonID] !== selectedAction) {
        const previousAction = peopleSelections[buttonID];

        if (peopleClickCounts[previousAction]) {
          peopleClickCounts[previousAction] -= 1;

          // Remove the previous voter from the list
          if (peopleVoterMap[previousAction]) {
            peopleVoterMap[previousAction].delete(timerPeopleNewName);
          }

          if (peopleClickCounts[previousAction] <= 0) {
            delete peopleClickCounts[previousAction];
          }
        }
      }

      // Mark this selection for the buttonID
      peopleSelections[buttonID] = selectedAction;

      // Increment vote count correctly
      peopleClickCounts[actionName] = (peopleClickCounts[actionName] || 0) + 1;

      // Store the voter
      peopleVoterMap[actionName].add(timerPeopleNewName);

      // Clear and update display
      peopleClickCountsList.innerHTML = '';
      for (let [key, count] of Object.entries(peopleClickCounts)) {
        if (count > 0) {
          const voters = Array.from(peopleVoterMap[key]).join(", ") || "Unknown";
          const listItem = document.createElement("li");
          listItem.textContent = `(${voters}) selected "${key}": ${count} time${count > 1 ? 's' : ''}`;
          peopleClickCountsList.appendChild(listItem);
        }
      }
    }








    function updateCounterDisplay() {
      document.getElementById("individualCount").innerText = counters.Individual;
      document.getElementById("particularCount").innerText = counters.Particular;
      document.getElementById("universalCount").innerText = counters.Universal;
    }

    function addContentSection(type, title, time, timerName) {
      const contentSection = document.createElement("div");
      contentSection.className = "content-section";

      let timerRunning = false;
      let timerInterval;
      let currentTime = time; // Save the original time for later use
      // <strong>${type}:</strong> ${title} - Time: <span class="time-display" contenteditable="true">${time}</span>

      contentSection.innerHTML = `
        <strong>${type} Name ${timerName}:</strong> ${title} - Time: <span class="time-display" contenteditable="true">${time}</span>
        <button class="remove-content-btn">‚ùå</button>
        <button class="play-pause-btn">‚ñ∂Ô∏è</button>
      `;

      contentDisplayContainer.appendChild(contentSection);

      const removeContentBtn = contentSection.querySelector(".remove-content-btn");
      removeContentBtn.addEventListener("click", () => {
        contentSection.remove();
        counters[type]--;
        updateCounterDisplay();
      });

      const playPauseBtn = contentSection.querySelector(".play-pause-btn");
      const timeDisplay = contentSection.querySelector(".time-display");

      playPauseBtn.addEventListener("click", () => {
        if (timerRunning) {
          clearInterval(timerInterval);
          playPauseBtn.innerText = "‚ñ∂Ô∏è";
        } else {
          // When starting, get the time from the contenteditable element
          let editedTime = timeDisplay.innerText;
          let [minutes, seconds] = editedTime.split(":").map(Number);

          timerInterval = setInterval(() => {
            if (seconds > 0) {
              seconds--;
            } else if (minutopicTimetes > 0) {
              minutes--;
              seconds = 59;
            } else {
              clearInterval(timerInterval);
            }
            editedTime = `${minutes}:${seconds < 10 ? "0" + seconds : seconds}`;
            timeDisplay.innerText = editedTime;
          }, 1000);
          playPauseBtn.innerText = "‚è∏Ô∏è";
        }
        timerRunning = !timerRunning;
      });
    }


    //////////////////////Next Function



    //working 2
    function openContentForm(contentType, timerComponent, assignedCategories, timerName) {
      // Remove existing form if any
      const existingForm = document.getElementById("contentForm");
      if (existingForm) {
        existingForm.remove();
      }

      // Create the form HTML
      const formHTML = `
    <div id="contentForm">
      <div><strong>Added By :</strong> ${timerName}</div>
      <input type="text" id="topicName" placeholder="${contentType} Selected is"/>
      <input type="text" id="topicTime" value="2:00" placeholder="Enter Time (e.g., 2 min)"/>
      <button id="submitContentBtn">Submit</button>
    </div>
  `;

      const contentForm = document.createElement("div");
      contentForm.innerHTML = formHTML;
      document.body.appendChild(contentForm);

      const submitContentBtn = contentForm.querySelector("#submitContentBtn");
      submitContentBtn.addEventListener("click", () => {
        const topicName = document.getElementById("topicName").value;
        const topicTime = document.getElementById("topicTime").value;

        if (topicName && topicTime) {
          addContentSection(contentType, topicName, topicTime, timerName);
          assignedCategories.add(contentType);
          counters[contentType]++;
          updateCounterDisplay();
          contentForm.remove();

          // ‚úÖ SEND topicName and topicTime via WebSocket
          const contentBtn = timerComponent.querySelector(".content-btn");
          const timerID = contentBtn?.getAttribute("data-id") || contentBtn?.getAttribute("id2") || "";

          const contentData = {
            cmd: "contentDropdownClick",
            msg: {
              selectedContent: contentType,
              timerName,
              timerID,
              topicName,
              topicTime
            }
          };

          socket.send(JSON.stringify(contentData));
          console.log("Submitted contentData:", contentData);
        }
      });
    }




    ///////////////NEXT FUNCTION (they must go in this order. )

    function createTimerComponent(allThisTimerDataFromServer, timerList) {
      //NOTE: Feb 19 2025: this timer function is called AFTER we return from server with server made global ID for this timer. The server keeps track of the ID not browser.
      let defaultTime = allThisTimerDataFromServer.remainingTime;//the timer on server is super precise so simplify here for drawing
      let minutes = Math.floor(defaultTime / 60); // Get the number of minutes
      let seconds = defaultTime % 60; // Get the remaining seconds

      // Format seconds as two digits (e.g., 5 becomes "05")
      seconds = seconds < 10 ? "0" + seconds : seconds;
      let formattedTime = `${minutes}:${seconds}`;
      defaultTime = formattedTime;
      let ascendingTime = allThisTimerDataFromServer.ascendingTime;
      minutes = Math.floor(ascendingTime / 60);
      seconds = ascendingTime % 60; // Get the remaining seconds

      // Format seconds as two digits (e.g., 5 becomes "05")
      seconds = seconds < 10 ? "0" + seconds : seconds;
      formattedTime = `${minutes}:${seconds}`;

      //asccendingTime = formattedTime;
      console.log("scendingCathcupTime:" + ascendingTime + " " + minutes + " " + seconds + " " + formattedTime);
      //formattedTime = minutes+":"+seconds;
      //ascendingTime=formattedTime
      let newTimerID = allThisTimerDataFromServer.timerServerID;
      let timerTitle = allThisTimerDataFromServer.name;
      let vetoValue = allThisTimerDataFromServer.veto;
      // let vetoValue = vetoTimerData.formVeto;
      console.log("veto value " + JSON.stringify(vetoValue));
      // let vetoValue = "";
      globalTimerIDs++
      console.log("Start createTimerComponent defaultTime:" + JSON.stringify(defaultTime) + ": timerTitle: " + timerTitle + " timerList:" + JSON.stringify(timerList));
      const timerComponent = document.createElement("div");
      timerComponent.className = "timer";
      timerComponent.id = newTimerID; //NOTE: March 13 2025: adding this ID to quickly find the DIV to make the timer green etc. Before the ID was not attached but only to the input parts below
      timerComponent.flow = "flow timer default";
      timerComponent.content = "content timer default";
      timerComponent.people = "people timer default";
      timerComponent.votesubmit = "votesubmit timer default";

      // Create the input elements first
      //const timerTitleInput = document.createElement("input");
      //timerTitleInput.setAttribute("type", "text");
      //timerTitleInput.setAttribute("placeholder", "Timer Title");
      //timerTitleInput.setAttribute("class", "timer-title");
      //timerTitleInput.setAttribute("id", `${newTimerID}-100`);
      //
      //timerComponent.appendChild(timerTitleInput);

      timerComponent.innerHTML = `
<input type="checkbox" class="timer-checkbox"/>
        <input data-id="${newTimerID}-1" type="text" value="${timerTitle}" placeholder="Timer Title" class="timer-title"/>
        <input data-id="${newTimerID}-2" type="text" value="${defaultTime}" class="timer-value"/> 
        <input data-id="${newTimerID}-3" type="text" value="${formattedTime}" class="timer-asc"/>
        <input data-id="${newTimerID}-4" type="text" value="${vetoValue}" placeholder="veto" class="timer-veto"/> <!-- Shorter width for veto -->

        
  <div class="flex-row">
    <div class="button-with-label">
      <button data-id="${newTimerID}-5" data-status="currently_paused" class="start-pause-btn">‚ñ∂Ô∏è</button>
      <small class="tiny-label">${timerTitle}</small>
    </div>
    <div class="button-with-label">
      <button data-id="${newTimerID}-6" class="reset-initial-btn">‚èèÔ∏è</button>
      <small class="tiny-label">${timerTitle}</small>
    </div>
    <div class="button-with-label">
      <button data-id="${newTimerID}-7" class="reset-default-btn">‚§µÔ∏è</button>
      <small class="tiny-label">${timerTitle}</small>
    </div>
    <div class="button-with-label">
      <button data-id="${newTimerID}-8" class="remove-btn">‚ùå</button>
      <small class="tiny-label">${timerTitle}</small>
    </div>
    <div class="button-with-label">
      <button data-id="${newTimerID}-9" class="form-btn" id="formbtn">Form</button>
      <small class="tiny-label">${timerTitle}</small>
    </div>
    <div class="button-with-label">
      <button data-id="${newTimerID}-10" class="content-btn" id="contentdata">Content</button>
      <small class="tiny-label">${timerTitle}</small>
    </div>
    <div class="button-with-label">
      <button data-id="${newTimerID}-11" class="people-btn" id="peoplebtn">People</button>
      <small class="tiny-label">${timerTitle}</small>
    </div>
    <div class="button-with-label">
      <button data-id="${newTimerID}-12" class="vote-btn" id="vote-btn" disabled>Vote</button>
      <small class="tiny-label">${timerTitle}</small>
    </div>
    <div class="button-with-label">
      <button data-id="${newTimerID}-13" class="donateUserTIme" id="donateUserTIme">Donate</button>
      <small class="tiny-label">${timerTitle}</small>
    </div>
  </div>
      `;
      // <input  data-id="${newTimerID}-timersenddata" class="datainputtimer" style="margin:0px 10px; display:none;" type="text" id="fname" name="fname"><br>

      // <button data-id="${newTimerID}-send" style="display:none;">Send</button>


      const titleInput = timerComponent.querySelector(`input[data-id="${newTimerID}-1"]`);
      const tinyLabels = timerComponent.querySelectorAll('.tiny-label');

      titleInput.addEventListener('input', function () {
        tinyLabels.forEach(label => {
          label.textContent = titleInput.value; // live update
        });
      });
      timerList.appendChild(timerComponent);

      console.log("Event Listener set in createTimerComponent: ");

      if (allThisTimerDataFromServer.isRunning) {//meaning when someone logs in if the timer is running it will be running right on login
        startTimer(newTimerID, allThisTimerDataFromServer.remainingTime)
        startAscendingTimer(newTimerID, allThisTimerDataFromServer.ascendingTime);
      }

      if (allThisTimerDataFromServer.remainingTime <= 0) {//the timer is out so make the background orange
        timerComponent.style.backgroundColor = 'orange';
      }

      //setTimeout(function() {
      const titleInputField = timerComponent.querySelector(`[data-id="${newTimerID}-1"]`);//timerComponent.querySelector('.timer-title'); // Use class selector
      console.log("titleInputField using querySelector:" + JSON.stringify(titleInputField));
      //}, 1000);




      titleInputField.addEventListener('blur', function () {

        const timerNewName = titleInputField.value; // Get the value entered by the user
        const timerNewTitleID = titleInputField.getAttribute('data-id'); // Get the value entered by the user
        let resetTimerName_timerServerID = "";
        const parts = timerNewTitleID.split('-');
        const firstPart = parts[0];
        resetTimerName_timerServerID = firstPart;//this firstPart is the timerServerID        
        console.log(firstPart);
        const ELMxID = 0; // You can change this to the actual ELMxID if dynamic
        console.log("Event Listener set in createTimerComponent: " + timerNewName);
        // Send the new timer name to the server when the user unfocuses the input field
        socket.send(JSON.stringify("inside of blur updateTimerTitleName"));
        let responseObject = { "cmd": "resetTimerName", "msg": { "ELMxID": 0, "timerServerID": resetTimerName_timerServerID, "timerNewName": timerNewName } }
        //workerDispatch(JSON.stringify(responseObject))
        socket.send(JSON.stringify(responseObject));
        console.log("Timer title sending to socket: " + timerNewName);
      });//end event handler blur
      ////////////////////////////////////////////////////////////////////////////////////

      // Select the input field for default time (assuming this is within a timer component)
      // const defaultTimeInputField = timerComponent.querySelector(`[data-id="${newTimerID}-2"]`); // Use correct data-id for default time

      // defaultTimeInputField.addEventListener('focus', function () {


      //   stopTimer(newTimerID);



      // });//end click



      // Select the input field for default time (assuming this is within a timer component)
      const defaultTimeInputField = timerComponent.querySelector(`[data-id="${newTimerID}-2"]`); // Use correct data-id for default time

      defaultTimeInputField.addEventListener('focus', function () {
        const focus_ELMxID = 0; // You can dynamically set this as needed. This is currently hardcoded as April 6 2025

        // Get the value entered by the user
        const defaultTime = defaultTimeInputField.value;

        // Get the data-id attribute value of the input field
        const focusTimeElementID = defaultTimeInputField.getAttribute('data-id');

        let focusTime_timerServerID = "";
        const parts = focusTimeElementID.split('-'); // Split the ID to get the timerServerID
        const firstPart = parts[0]; // The first part is the timerServerID
        focusTime_timerServerID = firstPart; // Set timerServerID to firstPart


        stopTimer(newTimerID);
        let responseObject = {
          cmd: "stopTimer",
          msg: {
            ELMxID: focus_ELMxID,
            timerServerID: focusTime_timerServerID,
          }//end msg
        };//end responseObject

        // Send the request to the server to update the timer state for all clients
        socket.send(JSON.stringify(responseObject));
        console.log("stopTimer sending to socket: " + JSON.stringify(responseObject));

        console.log("Default time sent to server: " + defaultTime);


      });//endfocus


      defaultTimeInputField.addEventListener('blur', function () {
        // Get the value entered by the user
        const defaultTime = defaultTimeInputField.value;

        // Get the data-id attribute value of the input field
        const defaultTimeElementID = defaultTimeInputField.getAttribute('data-id');

        let resetDefaultTime_timerServerID = "";
        const parts = defaultTimeElementID.split('-'); // Split the ID to get the timerServerID
        const firstPart = parts[0]; // The first part is the timerServerID
        resetDefaultTime_timerServerID = firstPart; // Set timerServerID to firstPart

        console.log("resetDefaultTime_timerServerID: " + resetDefaultTime_timerServerID);

        const ELMxID = 0; // You can dynamically set this as needed
        console.log("Event Listener set for default time update: " + defaultTime);

        let timeParts = defaultTime.split(":");

        // Convert minutes and seconds to integers
        let minutes = parseInt(timeParts[0], 10);
        let seconds = parseInt(timeParts[1], 10);

        // Convert the total time to seconds
        let totalSeconds = (minutes * 60) + seconds;

        // Send the updated default time to the server when the user unfocuses the input field
        socket.send(JSON.stringify("inside of blur updateDefaultTime"));


        // Create a response object to send to the server
        let responseObject = {
          "cmd": "resetDefaultTime",
          "msg": {
            "ELMxID": ELMxID,
            "timerServerID": resetDefaultTime_timerServerID,
            "defaultTime": totalSeconds
          }
        };

        // Send the response object to the server (via socket)
        console.log("responce of default timer hi" + JSON.stringify(responseObject));
        socket.send(JSON.stringify(responseObject));

        console.log("Default time sent to server: " + defaultTime);
      });




      const timerAscInputField = timerComponent.querySelector(`[data-id="${newTimerID}-3"]`); // Use the correct data-id for the ascending timer
      console.log("timerAscInputField using querySelector: " + JSON.stringify(timerAscInputField));

      timerAscInputField.addEventListener('blur', function () {
        // Get the value entered by the user
        const timerAscValue = timerAscInputField.value;

        // Get the data-id attribute value of the input field
        const timerAscElementID = timerAscInputField.getAttribute('data-id');

        let resetTimerAsc_timerServerID = "";
        const parts = timerAscElementID.split('-'); // Split the ID to get the timerServerID
        const firstPart = parts[0]; // The first part is the timerServerID
        resetTimerAsc_timerServerID = firstPart; // Set timerServerID to firstPart

        console.log("resetTimerAsc_timerServerID: " + resetTimerAsc_timerServerID);

        const ELMxID = 0; // You can dynamically set this as needed
        console.log("Event Listener set for ascending timer update: " + timerAscValue);

        // Send the updated ascending timer value to the server when the user unfocuses the input field
        socket.send(JSON.stringify("inside of blur updateAscendingTimer"));

        // Create a response object to send to the server
        let responseObject = {
          "cmd": "resetTimerAsc",
          "msg": {
            "ELMxID": ELMxID,
            "timerServerID": resetTimerAsc_timerServerID,
            "timerAscValue": timerAscValue
          }
        };

        // Send the response object to the server (via socket)
        console.log("Response for ascending timer: " + JSON.stringify(responseObject));
        socket.send(JSON.stringify(responseObject));

        console.log("Ascending timer value sent to server: " + timerAscValue);
      });



      // setTimeout(function() {
      const vetoInputField = timerComponent.querySelector(`[data-id="${newTimerID}-4"]`);
      console.log("vetoInputField using querySelector:" + JSON.stringify(vetoInputField));
      // }, 1000);

      vetoInputField.addEventListener('blur', function () {
        const vetoNewName = vetoInputField.value; // Get the value entered by the user
        const vetoNewTitleID = vetoInputField.getAttribute('data-id'); // Get the attribute ID
        const ELMxID = 0; // You can change this to the actual ELMxID if dynamic
        const newTimeVetoID = newTimerID;
        console.log("Event Listener set in createTimerComponent: " + vetoNewName);

        // Send the new veto name to the server when the user unfocuses the input field
        socket.send(JSON.stringify("inside of blur updateVetoName"));

        let responseObject = {
          "cmd": "resetVetoName",
          "msg": {
            "ELMxID": ELMxID,
            "newTimeVetoID": newTimeVetoID,
            "vetoNewTitleID": vetoNewTitleID,
            "vetoNewName": vetoNewName
          }
        };

        socket.send(JSON.stringify(responseObject));
        console.log("Veto title sending to socket: " + vetoNewName);
      });//end event handler blur



      const startPauseBtn = timerComponent.querySelector(`[data-id="${newTimerID}-5"]`);
      console.log("startPauseBtn using querySelector: " + JSON.stringify(startPauseBtn));
      startPauseBtn.addEventListener('click', function () {
        const ELMxID = 0; // You can change this to the actual ELMxID if dynamic
        let startPauseBtn_status = startPauseBtn.getAttribute("data-status");

        let timerServerID = startPauseBtn.getAttribute("data-id"); // Extract the timer ID
        timerServerID = parseInt(timerServerID.split('-')[0], 10);
        console.log("Event Listener (start/pause): " + startPauseBtn_status + " timerServerID" + timerServerID);

        // Toggle timer locally using our defined function
        //toggleTimer(isStarting);


        if (startPauseBtn_status == "currently_paused") {//then it means we've clicked it which will switch it to its opposite
          // Prepare data to send to the server
          let responseObject = {
            cmd: "startTimer",
            msg: {
              ELMxID: ELMxID,
              timerServerID: timerServerID,
            }//end msg
          };//end responseObject

          // Send the request to the server to update the timer state for all clients
          socket.send(JSON.stringify(responseObject));
          console.log("startTimer sending to socket: " + JSON.stringify(responseObject));

        } else {//it means the timer was running and we clicked it so now we are pausing it

          let responseObject = {
            cmd: "stopTimer",
            msg: {
              ELMxID: ELMxID,
              timerServerID: timerServerID,
            }//end msg
          };//end responseObject

          // Send the request to the server to update the timer state for all clients
          socket.send(JSON.stringify(responseObject));
          console.log("stopTimer sending to socket: " + JSON.stringify(responseObject));

        }//end if startPaustBTN_status

      });//end startPauseBtn.adddEventListener







      const contentBtn2 = document.getElementById("contentdata");
      console.log("CONTENTBUTTON:" + contentBtn2);

      // Create dropdown menu inside content-btn
      const contentBtn = timerComponent.querySelector(".content-btn");
      const dropdownMenu = document.createElement("div");
      dropdownMenu.classList.add("dropdown-menu");
      dropdownMenu.innerHTML = `
  <button class="dropdown-item" data-type="Individual">Individual</button>
  <button class="dropdown-item" data-type="Particular">Particular</button>
  <button class="dropdown-item" data-type="Universal">Universal</button>
`;

      // Append dropdown to timer component
      timerComponent.appendChild(dropdownMenu);

      let assignedCategories = new Set();

      contentBtn.addEventListener("click", () => {
        dropdownMenu.classList.toggle("show-dropdown");
      });

      dropdownMenu.addEventListener("click", (e) => {
        if (e.target.classList.contains("dropdown-item")) {
          document.querySelectorAll(".dropdown-item").forEach(item => {
            item.style.backgroundColor = ""; // Reset
          });

          const selectedContent = e.target.dataset.type;

          // üü° Get the timer name (assume it's in an input or span)
          const timerTitleInput = timerComponent.querySelector('[data-id$="-1"]'); // assuming your input has data-id ending in -1
          const timerName = timerTitleInput?.value || timerTitleInput?.innerText || "Unnamed Timer";

          // üü¢ Call with timer name now
          // openContentForm(selectedContent, timerComponent, assignedCategories);
          openContentForm(selectedContent, timerComponent, assignedCategories, timerName);

          e.target.style.backgroundColor = "brown";
          contentBtn.style.backgroundColor = "brown";
        }
      });



      document.addEventListener("click", (event) => {
        if (!contentBtn.contains(event.target) && !dropdownMenu.contains(event.target)) {
          dropdownMenu.classList.remove("show-dropdown");
        }
        if (!peopleBtn.contains(event.target) && !peopleDropdownMenu.contains(event.target)) {
          peopleDropdownMenu.classList.remove("show-dropdown");
        }
        if (!formBtn.contains(event.target) && !formDropdownMenu.contains(event.target)) {
          formDropdownMenu.classList.remove("show-dropdown");
        }
      });

      // Create dropdown menu inside form-btn
      const formBtn = timerComponent.querySelector(".form-btn");
      const formDropdownMenu = document.createElement("div");
      formDropdownMenu.classList.add("dropdown-menu");

      // Create Main Menu Items
      formDropdownMenu.innerHTML = `
    <div class="dropdown-item" id="turnbutton" data-timer-id="${newTimerID}-turn">1. Turn
      <div class="submenu">
        <button class="submenu-item" data-timerServerID="${newTimerID}-straightturn" id="straightturn">Straight Turn</button>
        <button class="submenu-item" data-timerServerID="${newTimerID}-directiveTurn" id="directiveTurn">Directive Turn</button>
        <button class="submenu-item" data-timerServerID="${newTimerID}-popcornTurn" id="popcornTurn">Popcorn Turn</button>
      </div>
    </div>
    <div class="dropdown-item" id="freeflowbutton" data-timer-id="${newTimerID}-freeflow">2. Free Flow
      <div class="submenu">
        <button class="submenu-item" data-timerServerID="${newTimerID}-fastFreeFlow">Fast Free Flow</button>
        <button class="submenu-item" data-timerServerID="${newTimerID}-teamFreeFlow">Team Free Flow</button>
        <button class="submenu-item" data-timerServerID="${newTimerID}-spreadFreeFlow">Spread Free Flow</button>
      </div>
    </div>
    <div class="dropdown-item" id="godmodebutton" data-timer-id="${newTimerID}-godmode">3. God Mode
      <div class="submenu">
        <button class="submenu-item" data-timerServerID="${newTimerID}-god">God</button>
        <button class="submenu-item" data-timerServerID="${newTimerID}-diety">Diety</button>
        <button class="submenu-item" data-timerServerID="${newTimerID}-spirit">Spirit</button>
      </div>
    </div>
  `;
      formBtn.appendChild(formDropdownMenu);



      // Toggle dropdown visibility
      // formBtn.addEventListener("click", () => {
      //   formDropdownMenu.classList.toggle("show-dropdown");
      // });


      //changes by subhadra
      // Toggle full dropdown menu visibility when clicking formBtn
      // formBtn.addEventListener("click", (e) => {
      //   e.stopPropagation(); // Prevent bubbling to body

      //   // Reset dropdown to its clean state before toggling visibility
      //   resetDropdownMenu();

      //   // Check if dropdown is already visible
      //   if (formDropdownMenu.classList.contains("show-dropdown")) {
      //     formDropdownMenu.classList.remove("show-dropdown");
      //   } else {
      //     formDropdownMenu.classList.add("show-dropdown");
      //   }
      // });

      // // Handle clicking dropdown items (Turn / Free Flow / God Mode)
      // const dropdownItems = formDropdownMenu.querySelectorAll('.dropdown-item');

      // dropdownItems.forEach(item => {
      //   item.addEventListener('click', (e) => {
      //     e.stopPropagation();

      //     // First, close all submenus (reset all submenus to hidden state)
      //     dropdownItems.forEach(otherItem => {
      //       if (otherItem !== item) {
      //         const otherSubmenu = otherItem.querySelector('.submenu');
      //         if (otherSubmenu) {
      //           otherSubmenu.classList.remove('show');
      //         }
      //       }
      //     });

      //     // Then, toggle the clicked submenu visibility
      //     const submenu = item.querySelector('.submenu');
      //     if (submenu) {
      //       submenu.classList.toggle('show');
      //     }

      //     // Close the whole dropdown when submenu item is clicked
      //     const submenuItems = item.querySelectorAll('.submenu-item');
      //     submenuItems.forEach(submenuItem => {
      //       submenuItem.addEventListener('click', (e) => {
      //         e.stopPropagation(); // Stop bubbling
      //         formDropdownMenu.classList.remove('show-dropdown'); // Close the dropdown
      //         resetDropdownMenu();  // Reset state to clean after closing dropdown
      //       });
      //     });
      //   });
      // });

      // // Reset dropdown to its clean state 
      // function resetDropdownMenu() {
      //   const submenus = formDropdownMenu.querySelectorAll('.submenu');
      //   submenus.forEach(submenu => {
      //     submenu.classList.remove('show');
      //   });

      //   // Remove hover effect or active states
      //   const dropdownItems = formDropdownMenu.querySelectorAll('.dropdown-item');
      //   dropdownItems.forEach(item => {
      //     item.classList.remove('hover'); // If you're using any hover class, remove it
      //   });
      // }



      formBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        formDropdownMenu.classList.toggle('show-dropdown');
        if (!formDropdownMenu.classList.contains('show-dropdown')) {
          resetDropdownMenu();
        }
      });
      const dropdownItems = formDropdownMenu.querySelectorAll('.dropdown-item');
      dropdownItems.forEach(item => {
        item.addEventListener('click', (e) => {
          e.stopPropagation();
          const submenu = item.querySelector('.submenu');
          dropdownItems.forEach(otherItem => {
            if (otherItem !== item) {
              const otherSubmenu = otherItem.querySelector('.submenu');
              if (otherSubmenu) otherSubmenu.classList.remove('show');
            }
          });
          if (submenu) submenu.classList.toggle('show');
        });
      });
      const submenuItems = formDropdownMenu.querySelectorAll('.submenu-item');
      submenuItems.forEach(submenuItem => {
        submenuItem.addEventListener('click', (e) => {
          e.stopPropagation();
          formDropdownMenu.classList.remove('show-dropdown');
          resetDropdownMenu();
          const timerId = submenuItem.dataset.timerServerID;
          console.log('Start timer for', timerId);
        });
      });

      function resetDropdownMenu() {
        const submenus = formDropdownMenu.querySelectorAll('.submenu');
        submenus.forEach(submenu => submenu.classList.remove('show'));
      }


      // Create dropdown menu inside people-btn
      const peopleBtn = timerComponent.querySelector(".people-btn");
      const peopleDropdownMenu = document.createElement("div");
      // const timerNewName = titleInputField.value;

      // console.log("timerNewName test" + timerNewName);
      peopleDropdownMenu.classList.add("dropdown-menu");

      peopleDropdownMenu.innerHTML = `
  <button class="dropdown-item" data-action="${newTimerID}-same">Same People</button>
  <button class="dropdown-item" data-action="${newTimerID}-remove">Remove People</button>
  <button class="dropdown-item" data-action="${newTimerID}-add">Add People</button>
`;

      // Append the dropdown to the button
      peopleBtn.appendChild(peopleDropdownMenu);

      // Toggle dropdown visibility
      peopleBtn.addEventListener("click", () => {
        peopleDropdownMenu.classList.toggle("show-dropdown");
      });



      // Handle click events for people dropdown
      peopleDropdownMenu.addEventListener("click", (e) => {

        const timerNewName = titleInputField ? titleInputField.value.trim() : ""; // Fetch updated value
        // console.log("Updated timerNewName:", timerNewName);




        if (e.target.classList.contains("dropdown-item")) {
          // Reset the background color for all items
          const items = peopleDropdownMenu.querySelectorAll(".dropdown-item");


          items.forEach(item => {
            item.style.backgroundColor = ""; // Reset all item backgrounds
          });

          // Apply background color to the clicked item
          // e.target.style.backgroundColor = "green"; // You can change the color as needed
          // peopleBtn.style.backgroundColor = "green"; // Change to desired color

          const action = e.target.dataset.action;

          let ELMxID = 0;
          // Construct the data object to send via WebSocket

          console.log("Clicked Button:", e.target);
          // console.log("Extracted Button Text:", e.target.innerText.trim());
          buttonPeopleText = e.target.innerText.trim();

          const data = {
            cmd: "peopleDropdownClick",
            msg: {
              action: action,
              "ELMxID": ELMxID,
              buttonID: peopleBtn.getAttribute("data-id"),
              timerPeopleNewName: timerNewName,
              buttonPeopleText: buttonPeopleText
            }
          };

          // Send the data via WebSocket
          socket.send(JSON.stringify(data));

          console.log(`Sent action to server: ${action}`);

          // Close the dropdown after selection
          peopleDropdownMenu.classList.remove("show-dropdown");
        }
      });





      let clickCount = 0;
      let userNames = {}; // Store usernames dynamically
      let donationCounts = {}; // Tracks how many times each user has donated to another


      function updateUsernames() {
        document.querySelectorAll(`[data-id$="-1"]`).forEach(input => {
          let timerID = input.getAttribute("data-id").split("-")[0];
          userNames[timerID] = input.value.trim() || `User ${timerID}`;
        });
      }

      function getUserOptions(currentUserID, excludeIDs = []) {
        updateUsernames();
        let options = "";
        Object.entries(userNames).forEach(([userID, userName]) => {
          if (userID !== currentUserID && !excludeIDs.includes(userID)) {
            options += `<option value="${userID}">${userName}</option>`;
          }
        });
        return options;
      }

      function updateUserDropdowns() {
        document.querySelectorAll(".donation-controls select").forEach(selectElement => {
          let currentUserID = selectElement.closest(".user-card")?.getAttribute("data-user-id");
          selectElement.innerHTML = getUserOptions(currentUserID);
        });
      }

      document.addEventListener("input", function (event) {
        if (event.target.matches(`[data-id$="-1"]`)) {
          updateUsernames();
          updateUserDropdowns();
        }
      });

      const citizenCountElement = document.getElementById("numberCitizenTimers");
      if (typeof window.citizenObserver === "undefined" && citizenCountElement) {
        window.citizenObserver = new MutationObserver(() => {
          updateUserDropdowns();
        });
        window.citizenObserver.observe(citizenCountElement, { childList: true, subtree: true });
      }

      // function attachDonateButton(cardElement, fromUserID, timerName) {
      //   const donateBtn = cardElement.querySelector(".donate-btn");
      //   donateBtn?.addEventListener("click", () => {
      //     const minutesInput = cardElement.querySelector("input[type='number']:nth-child(1)");
      //     const secondsInput = cardElement.querySelector("input[type='number']:nth-child(2)");
      //     const recipientSelect = cardElement.querySelector("select");

      //     const donateMinutes = parseInt(minutesInput?.value || "0");
      //     const donateSeconds = parseInt(secondsInput?.value || "0");
      //     const toUserID = parseInt(recipientSelect?.value);
      //     const totalSeconds = donateMinutes * 60 + donateSeconds;

      //     if (!toUserID || totalSeconds <= 0) {
      //       alert("Please select a recipient and enter valid time to donate.");
      //       return;
      //     }

      //     const donationKey = `${fromUserID}_${toUserID}`;
      //     donationCounts[donationKey] = (donationCounts[donationKey] || 0) + 1;

      //     const donationData = {
      //       fromUserID,
      //       toUserID,
      //       timerName,
      //       minutes: donateMinutes,
      //       seconds: donateSeconds,
      //       totalSeconds
      //     };

      //     if (donationCounts[donationKey] > 1) {
      //       // alert("You have already donated 1 times. Approval required from another user.");
      //       console.log("donationData", donationData);
      //       socket.send(JSON.stringify({ cmd: "showApproval", msg: donationData }));

      //     } else {
      //       sendDonation(donationData);
      //     }
      //   });
      // }



      function attachDonateButton(cardElement, fromUserID, timerName) {
        const donateBtn = cardElement.querySelector(".donate-btn");
        donateBtn?.addEventListener("click", async () => {
          const minutesInput = cardElement.querySelector("input[type='number']:nth-child(1)");
          const secondsInput = cardElement.querySelector("input[type='number']:nth-child(2)");
          const recipientSelect = cardElement.querySelector("select");

          const donateMinutes = parseInt(minutesInput?.value || "0");
          const donateSeconds = parseInt(secondsInput?.value || "0");
          const toUserID = parseInt(recipientSelect?.value);
          const totalSeconds = donateMinutes * 60 + donateSeconds;

          if (!toUserID || totalSeconds <= 0) {
            alert("Please select a recipient and enter valid time to donate.");
            return;
          }

          const donationData = {
            fromUserID,
            toUserID,
            timerName,
            minutes: donateMinutes,
            seconds: donateSeconds,
            totalSeconds
          };

          // üõë NEW: Ask server about previous donation count
          checkDonationCount(fromUserID, toUserID).then((previousDonationCount) => {
            console.log(`üßÆ Previous donation count from ${fromUserID} to ${toUserID}:`, previousDonationCount);

            if (previousDonationCount >= 1) {
              console.log("üõ°Ô∏è Approval required before donating again:", donationData);
              socket.send(JSON.stringify({ cmd: "showApproval", msg: donationData }));
            } else {
              console.log("üöÄ First donation, sending directly:", donationData);
              sendDonation(donationData);
            }
          }).catch((err) => {
            console.error("‚ùå Failed to check donation count:", err);
          });
        });
      }

      // üÜï helper function to ask server about donation count
      function checkDonationCount(fromUserID, toUserID) {
        return new Promise((resolve, reject) => {
          const checkMsg = {
            cmd: "checkDonationCount",
            msg: { fromUserID, toUserID }
          };

          // Listen for server response once
          function onMessage(event) {
            const message = JSON.parse(event.data);
            if (message.cmd === "checkDonationCountResult" &&
              message.msg.fromUserID === fromUserID &&
              message.msg.toUserID === toUserID) {
              socket.removeEventListener("message", onMessage);
              resolve(message.msg.donationCount || 0);
            }
          }

          socket.addEventListener("message", onMessage);

          // Send request to server
          socket.send(JSON.stringify(checkMsg));

          // Optional timeout fallback
          setTimeout(() => {
            socket.removeEventListener("message", onMessage);
            reject(new Error("Timeout waiting for donation count"));
          }, 3000);
        });
      }





      // function sendDonation(data, approverID = null) {
      //   const payload = {
      //     cmd: "donateTime",
      //     msg: {
      //       ELMxID: 0,
      //       fromUserID: data.fromUserID,
      //       toUserID: data.toUserID,
      //       timerName: data.timerName,
      //       minutes: data.minutes,
      //       seconds: data.seconds,
      //       totalSeconds: data.totalSeconds
      //     }
      //   };

      //   if (approverID) {
      //     payload.msg.approvedByID = approverID;
      //     payload.msg.approvedByName = userNames[approverID] || `User ${approverID}`;
      //   }

      //   socket.send(JSON.stringify(payload));
      //   console.log("Donation sent via WebSocket:", payload);
      // }




      document.querySelectorAll(`[data-id="${newTimerID}-13"]`).forEach(button => {
        button.addEventListener("click", function () {
          const timerTitleInput = document.querySelector(`[data-id="${newTimerID}-1"]`);
          const timerTitle = timerTitleInput ? timerTitleInput.value.trim() : "Untitled Timer";
          const currentUserID = newTimerID;

          const defaultTimeInput = document.querySelector(`[data-id="${newTimerID}-2"]`);
          const timerValue = defaultTimeInput ? defaultTimeInput.value : "00:00";
          let [minutes, seconds] = timerValue.split(":").map(Number);
          minutes = isNaN(minutes) ? 0 : minutes;
          seconds = isNaN(seconds) ? 0 : seconds;

          let existingCard = this.nextElementSibling;

          if (existingCard && existingCard.classList.contains("user-card")) {
            existingCard.remove();
          } else {
            let userOptions = getUserOptions(currentUserID);
            let userCardHTML = `
        <div class="user-card" data-user-id="${currentUserID}">
          <div class="donation-controls">
            <input type="number" min="0" max="60" value="1"> min
            <input type="number" min="0" max="59" value="0"> sec
            <select>${userOptions}</select>
            <button class="donate-btn">Donate</button>
          </div>
        </div>
      `;

            let wrapper = document.createElement("div");
            wrapper.innerHTML = userCardHTML;
            let cardElement = wrapper.firstElementChild;

            this.after(cardElement);
            attachDonateButton(cardElement, currentUserID, timerTitle);
          }
        });
      });






      function setupDropdown(dropdownMenu) {
        const parentButtons = dropdownMenu.querySelectorAll(".dropdown-item");
        const allButtons = dropdownMenu.querySelectorAll(".submenu-item");
        const formbtn = document.getElementById("formbtn"); // Get form button

        if (!window.submenuClickCounts) {
          window.submenuClickCounts = {};
        }


        function activateButton(selectedButton) {
          console.log("In activateButton");

          // Reset background colors
          parentButtons.forEach(button => button.style.backgroundColor = "");
          allButtons.forEach(button => button.style.backgroundColor = "");

          // Highlight the selected button
          selectedButton.style.backgroundColor = "green";
          const formbtn = selectedButton.closest(".form-btn");

          const parentButton = selectedButton.closest(".dropdown-item");
          if (parentButton) parentButton.style.backgroundColor = "green";
          if (formbtn) formbtn.style.backgroundColor = "green";

          // Get button text and track clicks
          const buttonText = selectedButton.innerText.trim();
          window.submenuClickCounts[buttonText] = (window.submenuClickCounts[buttonText] || 0) + 1;
          console.log(`${buttonText} clicked ${window.submenuClickCounts[buttonText]} times`);

          // Get IDs
          const timerSubmenuServerID = selectedButton.getAttribute("data-timerServerID");
          const timerdropdownID = selectedButton.closest(".dropdown-item")?.getAttribute("data-timer-id");
          const formButtonID = selectedButton.closest(".form-btn")?.getAttribute("data-id");
          const timerNewName = titleInputField.value;

          console.log("Timer Dropdown ID:", timerdropdownID);
          console.log("Timer Server ID:", timerSubmenuServerID);
          console.log("Form Button ID:", formButtonID);

          if (selectedButton.dataset.clicked) return;
          selectedButton.dataset.clicked = true;

          // Hide all other timer containers except the one for the selected data-timerServerID
          document.querySelectorAll(".timer-container").forEach(container => {
            if (container.getAttribute("data-timerServerID") !== timerSubmenuServerID) {
              container.style.display = "none";
            }
          });

          // Find or create the timer container for this specific timerServerID
          let timerContainer = document.querySelector(`div[data-timerServerID="${timerSubmenuServerID}"]`);

          if (!timerContainer) {
            timerContainer = document.createElement("div");
            timerContainer.setAttribute("data-timerServerID", timerSubmenuServerID);
            timerContainer.classList.add("timer-container");
            timerContainer.innerHTML = `
            <div class = "scroll-wrapper">
            <div class="scroll-container" id="scrollArea-${timerSubmenuServerID}">
                <div id="minutes-${timerSubmenuServerID}" class="scroll-box"></div>
                <div id="seconds-${timerSubmenuServerID}" class="scroll-box"></div>
                </div>
                <button id="setTimerBtn-${timerSubmenuServerID}"  class="formbtntimersubmenu">Set Timer</button>
                
            </div>
        `;
            formbtn.parentNode.insertBefore(timerContainer, formbtn.nextSibling);

            // Populate the scroll boxes
            populateScrollBox(`minutes-${timerSubmenuServerID}`, 60);
            populateScrollBox(`seconds-${timerSubmenuServerID}`, 60);

            const setBtn = timerContainer.querySelector(`#setTimerBtn-${timerSubmenuServerID}`);
            const scrollWrapper = timerContainer.querySelector(".scroll-wrapper");

            setBtn.addEventListener("click", () => {
              scrollWrapper.style.display = "none"; // Completely hides the timer selector UI
            });

          } else {
            // Toggle visibility of the existing timer container
            timerContainer.style.display = (timerContainer.style.display === "none" || timerContainer.style.display === "") ? "block" : "none";
            const scrollWrapper = timerContainer.querySelector(".scroll-wrapper");
            scrollWrapper.style.display = "block";
          }

          // Set correct send button for this specific timer
          const sendButton = timerContainer.querySelector(".formbtntimersubmenu");
          sendButton.onclick = function () {
            const selectedMinute = document.querySelector(`#minutes-${timerSubmenuServerID} .selected`)?.textContent || "00";
            const selectedSecond = document.querySelector(`#seconds-${timerSubmenuServerID} .selected`)?.textContent || "00";

            const newtimerinputfiled = `${selectedMinute}:${selectedSecond}`;

            console.log('newtimerinputfiled', newtimerinputfiled);
            const data = {
              cmd: "submenuClick",
              msg: {
                ELMxID: 0,
                timerSubmenuServerID: timerSubmenuServerID,
                formButtonID: formButtonID,
                newtimerinputfiled: newtimerinputfiled,
                timerdropdownID: timerdropdownID,
                timerFromNewName: timerNewName,
                buttonText: buttonText
              }
            };

            console.log("Sending data:", JSON.stringify(data));
            socket.send(JSON.stringify(data));
          };

          setTimeout(() => {
            delete selectedButton.dataset.clicked;
          }, 500);
        }

        // Ensure each button activates its own timer container
        allButtons.forEach(button => {
          button.addEventListener("click", () => {
            activateButton(button);
            console.log('Sub item clicked');
          });
        });

      }

      // Initial setup for existing dropdowns
      document.querySelectorAll(".dropdown-menu").forEach(setupDropdown);

      // Observe for new dropdowns being added dynamically
      const observer = new MutationObserver(mutations => {
        mutations.forEach(mutation => {
          mutation.addedNodes.forEach(node => {
            if (node.classList && node.classList.contains("dropdown-menu")) {
              setupDropdown(node);
            }
          });
        });
      });

      // Start observing the document for new dropdowns
      observer.observe(document.body, { childList: true, subtree: true });

      //Change the Reset Button Colour in case in mid vote, colours will update
      // Get the button DOM element
      const resetVotesBtn = document.getElementById("resetVotesBtn");




      // Calculate the percentage of totalVotes compared to numberCitizenTimers
      const votePercentage = (totalVotes / numberCitizenTimers) * 100;
      console.log("VotePercentage Of Timers:" + totalVotes + " " + numberCitizenTimers + " " + votePercentage);

      // Use a switch-case style logic to determine the button's color
      if (totalVotes == 0 && numberCitizenTimers == 0) {
        resetVotesBtn.style.backgroundColor = 'black';
        resetVotesBtn.style.color = 'white';
      } else if (votePercentage < 10) {
        resetVotesBtn.style.backgroundColor = 'black';
        resetVotesBtn.style.color = 'white';
      } else if (votePercentage >= 10 && votePercentage < 70) {
        resetVotesBtn.style.backgroundColor = 'red';
        resetVotesBtn.style.color = 'black';
      } else if (votePercentage >= 70 && votePercentage < 100) {
        resetVotesBtn.style.backgroundColor = 'orange';
        resetVotesBtn.style.color = 'black';
      } else if (votePercentage === 100) {
        resetVotesBtn.style.backgroundColor = 'green';
        resetVotesBtn.style.color = 'black';
      }





      // Function to enable the vote button when all required buttons are clicked
      function enableVoteButton(flexRow) {
        const buttons = flexRow.querySelectorAll('.form-btn, .content-btn, .people-btn');
        const voteBtn = flexRow.querySelector('.vote-btn');

        // Check if all required buttons are clicked
        const allClicked = [...buttons].every(button => button.classList.contains('clicked'));

        // Enable or disable the vote button accordingly
        if (allClicked) {
          voteBtn.classList.remove('disabled');
          voteBtn.disabled = false;
        } else {
          voteBtn.classList.add('disabled');
          voteBtn.disabled = true;
        }



        // Send update to the server
        const voteButtonID = voteBtn.getAttribute("data-id"); // Assuming each vote button has a unique ID
        socket.send(JSON.stringify({
          cmd: "updateVoteButton",
          msg: {
            ELMxID: 0,
            voteButtonID: voteButtonID,
            isEnabled: allClicked
          }
        }));

        console.log("Sent updateVoteButton request to server:", voteButtonID, allClicked);



      }

      // Event listener for dynamically added buttons
      document.addEventListener('click', function (event) {
        if (event.target.matches('.form-btn, .content-btn, .people-btn')) {
          event.target.classList.add('clicked');
          const flexRow = event.target.closest('.flex-row');
          if (flexRow) {
            enableVoteButton(flexRow);
          }
        }
      });


      return timerComponent;
    }//end createTimerComponent







    //********************************************************************






    //MAIN Start Of Page Loading (the above createTimerComponent is called within AFTER the DOM loads) 
    document.addEventListener("DOMContentLoaded", () => {

      //Mark/Nabin, where you left off: comment out these const variables and put them in setGlobalVariableOnceDOMContentLoaded and call global versions of these from within the function and set them to the new DOM elements created
      setGlobalVariablesOnceDOMContentLoaded();
      synchronizeScreenDraw();
      const timerList = document.getElementById("timerList");
      const addTimerBtn = document.getElementById("addTimerBtn");
      const defaultTimeInput = document.getElementById("defaultTime");
      const notifyCheckbox = document.getElementById("notifyCheckbox");
      const voteDataDiv = document.getElementById("voteData"); // Total vote display

      const contentDisplayContainer = document.getElementById("contentDisplayContainer");
      console.log("DOMContentLoaded: timerList:" + JSON.stringify(timerList));


      let totalVotes = 0; // Global vote count to track total votes
      let currentRunningTimer = null; // Track the currently running timer

      addTimerBtn.style.color = "green"; // Optional: Set the color to green




      addTimerBtn.addEventListener("click", addTimer);


      notifyCheckbox.addEventListener("change", function () {
        if (this.checked) {
          requestNotificationPermission();
        }
      });

      // addTimerBtn.addEventListener("click", addTimer);
      //resetVotesBtn.addEventListener("click", resetVotes); // Add listener for reset vote button

    }); ////end DOMContentLoaded







    // /*scroll effect in form submenu*/

    let selectedMinute = 1;  // Default to 1 minute
    let selectedSecond = 0;
    let formSubmenuTimerSet = false;
    let formSubmenuTimerTime = null;

    function populateScrollBox(id, range) {
      const box = document.getElementById(id);
      if (!box) return;

      box.innerHTML = "";  // Clear previous entries

      let defaultSelection = 0;
      if (id.includes("minutes")) defaultSelection = 1; // Set default to 1 minute

      for (let i = 0; i < range; i++) {
        let div = document.createElement("div");
        div.textContent = i.toString().padStart(2, '0');
        div.classList.add("time-option");

        if (i === defaultSelection) {
          div.classList.add("selected");  // Default selection
          selectedMinute = i;
        }

        div.onclick = function () {
          selectTime(id, div, i);
        };
        box.appendChild(div);
      }

      // ‚úÖ Scroll to default selection
      setTimeout(() => {
        let defaultElement = box.children[defaultSelection];
        if (defaultElement) {
          box.scrollTop = defaultElement.offsetTop;
        }
      }, 100);

      // ‚úÖ Auto-select when scrolling
      box.addEventListener("scroll", () => {
        let items = box.children;
        let closest = null;
        let minDiff = Infinity;

        for (let item of items) {
          let diff = Math.abs(item.offsetTop - box.scrollTop);
          if (diff < minDiff) {
            minDiff = diff;
            closest = item;
          }
        }

        if (closest) {
          let value = parseInt(closest.textContent);
          selectTime(id, closest, value);
        }
      });
    }

    function selectTime(id, element, value) {
      document.querySelectorAll(`#${id} div`).forEach(el => el.classList.remove("selected"));
      element.classList.add("selected");

      if (id.includes("minutes")) selectedMinute = value;
      if (id.includes("seconds")) selectedSecond = value;

      console.log(`üéØ Selected ${id}: ${value}`);
    }

    function setFormSubmenuTimer() {
      formSubmenuTimerTime = new Date();
      formSubmenuTimerTime.setMinutes(selectedMinute);
      formSubmenuTimerTime.setSeconds(selectedSecond);
      formSubmenuTimerTime.setMilliseconds(0);
      formSubmenuTimerSet = true;

      let timerStatus = `Timer set for ${selectedMinute}:${selectedSecond.toString().padStart(2, '0')}`;
      document.getElementById("form-submenu-timer-status").textContent = timerStatus;
      document.getElementById("form-submenu-timer-input").value = timerStatus;
    }

    // Check the timer every second
    setInterval(() => {
      if (formSubmenuTimerSet) {
        let now = new Date();
        if (now.getMinutes() === formSubmenuTimerTime.getMinutes() && now.getSeconds() === formSubmenuTimerTime.getSeconds()) {
          alert("‚è≥ Timer Completed!");
          formSubmenuTimerSet = false;
        }
      }
    }, 1000);

    populateScrollBox("minutes", 60);
    populateScrollBox("seconds", 60);


    /*scroll effect in form submenu end*/




  </script>

</body>

</html>